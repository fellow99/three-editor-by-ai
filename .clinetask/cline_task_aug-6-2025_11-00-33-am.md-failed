**User:**

<task>
useObjectSelection.jsä¸­ï¼Œå¯¹è±¡é«˜äº®çš„åŠŸèƒ½æ˜¯ç”¨ä¿®æ”¹æè´¨æ¥å®ç°çš„ï¼ˆæ€§èƒ½å¤ªå·®ï¼‰ï¼Œæ”¹ä¸ºæ¨¡å‹è½®å»“å‘å…‰ï¼ˆOutlinePassï¼‰çš„æ–¹å¼å®ç°é€‰ä¸­å¯¹è±¡é«˜äº®ã€‚
ç»“åˆREADME.mdæ–‡æ¡£ä¸­çš„åå¤„ç†æœºåˆ¶ã€‚
</task>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2

# VSCode Open Tabs
(No open tabs)

# Current Time
2025/8/6 ä¸Šåˆ10:55:09 (Asia/Shanghai, UTC+8:00)

# Current Working Directory (d:/pci-workspace/3D/three-editor-by-ai) Files
.gitignore
index.html
LICENSE
package-lock.json
package.json
README.md
vite.config.js
public/
public/vite.svg
src/
src/App.vue
src/Editor.vue
src/main.js
src/style.css
src/assets/
src/assets/vue.svg
src/components/
src/components/editor/
src/components/editor/AssetBrowser.vue
src/components/editor/EditorFooter.vue
src/components/editor/Inspector.vue
src/components/editor/ObjectItem.vue
src/components/editor/PropertyPanel.vue
src/components/editor/Toolbar.vue
src/components/scene/
src/components/scene/Camera.vue
src/components/scene/CubeViewportControls.vue
src/components/scene/InteractionHints.vue
src/components/scene/ObjectGizmo.vue
src/components/scene/SceneViewer.vue
src/components/scene/ViewportControls.vue
src/composables/
src/composables/useAssets.js
src/composables/useObjectSelection.js
src/composables/useScene.js
src/composables/useTransform.js
src/core/
src/core/AssetLoader.js
src/core/InputManager.js
src/core/ObjectManager.js
src/core/SceneManager.js
src/services/
src/services/api.js
src/utils/
src/utils/fileUtils.js
src/utils/geometryUtils.js
src/utils/mathUtils.js

# Git Remote URLs
origin: https://github.com/fellow99/three-editor-by-ai.git

# Context Window Usage
0 / 128K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. ç”¨æˆ·è¦æ±‚å°† useObjectSelection.js ä¸­å¯¹è±¡é«˜äº®çš„å®ç°æ–¹å¼ï¼Œä»â€œä¿®æ”¹æè´¨â€æ”¹ä¸ºâ€œä½¿ç”¨ OutlinePass è½®å»“å‘å…‰â€ã€‚
2. éœ€ç»“åˆ README.md ä¸­çš„åå¤„ç†æœºåˆ¶ï¼Œè¯´æ˜é¡¹ç›®å·²æœ‰åå¤„ç†æ¡†æ¶ï¼Œéœ€å…¼å®¹é›†æˆ OutlinePassã€‚
3. éœ€å…ˆæŸ¥çœ‹ README.md äº†è§£åå¤„ç†æœºåˆ¶ç»†èŠ‚ï¼Œå†æŸ¥çœ‹ useObjectSelection.js ç°æœ‰é«˜äº®å®ç°ï¼Œæœ€åå®ç°æ›¿æ¢ã€‚
4. éœ€è¦ç¡®è®¤ OutlinePass çš„é›†æˆç‚¹å’Œå¯¹è±¡é€‰ä¸­é€»è¾‘çš„è°ƒç”¨å…³ç³»ã€‚
</thinking>

<read_file>
<path>README.md</path>
</read_file>

---

**User:**

[read_file for 'README.md'] Result:
# 3D åœºæ™¯ç¼–è¾‘å™¨ (Three Editor by AI)

ä¸€ä¸ªåŸºäº Vue 3 + Three.js çš„ç°ä»£åŒ–3Dåœºæ™¯ç¼–è¾‘å™¨ï¼Œæ”¯æŒä¸‰ç»´æ¨¡å‹çš„æ‹–æ”¾ã€è°ƒæ•´å’Œå±æ€§é…ç½®ã€‚

## âœ… åŠŸèƒ½ä½“ç³»
- 3Dåœºæ™¯æ¸²æŸ“å’Œç®¡ç†
- å¤šç§åŸºç¡€å‡ ä½•ä½“åˆ›å»º
- å®Œæ•´çš„å¯¹è±¡å˜æ¢ç³»ç»Ÿï¼ˆç§»åŠ¨ã€æ—‹è½¬ã€ç¼©æ”¾ï¼‰
- å•é€‰ï¼ˆå¤šé€‰ã€æ¡†é€‰åŠŸèƒ½å·²ç§»é™¤ï¼Œä»…æ”¯æŒå•é€‰ï¼‰
- æ’¤é”€é‡åšå†å²è®°å½•
- 3Dæ¨¡å‹å’Œçº¹ç†åŠ è½½ï¼ˆGLTFã€OBJã€FBXç­‰æ ¼å¼ï¼‰
- æ‹–æ‹½ä¸Šä¼ å’Œèµ„æºç®¡ç†
- ç›¸æœºæ§åˆ¶å’Œé¢„è®¾è§†è§’
- æè´¨ç¼–è¾‘å’Œå±æ€§è°ƒæ•´
- åœºæ™¯åºåˆ—åŒ–å’Œå¯¼å…¥å¯¼å‡º

## ğŸš€ æŠ€æœ¯æ ˆ

- **å‰ç«¯æ¡†æ¶**: Vue 3 + Vite
- **3Då¼•æ“**: Three.js
- **æ„å»ºå·¥å…·**: Vite
- **ç½‘ç»œè¯·æ±‚**: Fetch API
- **å·¥å…·åº“**: 
  - Lodash - å®ç”¨å·¥å…·å‡½æ•°åº“
  - Day.js - è½»é‡çº§æ—¥æœŸæ—¶é—´åº“

## ğŸ“ é¡¹ç›®ç»“æ„

> 2025-08-05ï¼šToolbar.vue å·²ç§»é™¤â€œè®¾ç½®â€åˆ†ç»„åŠâ€œç½‘æ ¼å¸é™„ã€çº¿æ¡†æ¨¡å¼â€ç›¸å…³åŠŸèƒ½ã€‚

```
three-editor-by-ai/
â”œâ”€â”€ public/                     # é™æ€èµ„æº
â”‚   â””â”€â”€ vite.svg
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ assets/                 # é™æ€èµ„æº (3Dæ¨¡å‹ã€çº¹ç†ç­‰)
â”‚   â”‚   â””â”€â”€ vue.svg
â”‚   â”œâ”€â”€ components/             # Vue ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ editor/            # ç¼–è¾‘å™¨ UI ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ PropertyPanel.vue    # å±æ€§é¢æ¿
â”‚   â”‚   â”‚   â”œâ”€â”€ Toolbar.vue          # å·¥å…·æ 
â”‚   â”‚   â”‚   â”œâ”€â”€ AssetBrowser.vue     # èµ„æºæµè§ˆå™¨
â”‚   â”‚   â”‚   â””â”€â”€ Inspector.vue        # å¯¹è±¡æ£€æŸ¥å™¨
â”‚   â”‚   â”œâ”€â”€ scene/             # 3D åœºæ™¯ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ SceneViewer.vue      # ä¸»åœºæ™¯è§†å›¾
â”‚   â”‚   â”‚   â”œâ”€â”€ InteractionHints.vue     # æ“ä½œæç¤ºç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ ViewportControls.vue     # è§†å›¾æ§åˆ¶é¢æ¿ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ CubeViewportControls.vue # ç«‹æ–¹ä½“è§†è§’æ§ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ ObjectGizmo.vue      # å¯¹è±¡æ“ä½œæ§åˆ¶å™¨
â”‚   â”‚   â”‚   â””â”€â”€ Camera.vue           # ç›¸æœºæ§åˆ¶
â”‚   â”œâ”€â”€ composables/           # Vue Composition API å¯ç»„åˆå‡½æ•°
â”‚   â”‚   â”œâ”€â”€ useScene.js        # åœºæ™¯ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ useObjectSelection.js  # å¯¹è±¡é€‰æ‹©
â”‚   â”‚   â”œâ”€â”€ useTransform.js    # å˜æ¢æ“ä½œ
â”‚   â”‚   â””â”€â”€ useAssets.js       # èµ„æºç®¡ç†
â”‚   â”œâ”€â”€ core/                  # æ ¸å¿ƒ Three.js é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ SceneManager.js    # åœºæ™¯ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ ObjectManager.js   # å¯¹è±¡ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ InputManager.js    # è¾“å…¥å¤„ç†
â”‚   â”‚   â””â”€â”€ AssetLoader.js     # èµ„æºåŠ è½½å™¨
â”‚   â”œâ”€â”€ api/                  # API æ¥å£
â”‚   â”‚   â”œâ”€â”€ *.api.js            # å„ç§æ¨¡å—APIæ¥å£
â”‚   â”œâ”€â”€ utils/                 # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ mathUtils.js      # æ•°å­¦å·¥å…·
â”‚   â”‚   â”œâ”€â”€ geometryUtils.js  # å‡ ä½•å·¥å…·
â”‚   â”‚   â””â”€â”€ fileUtils.js      # æ–‡ä»¶å¤„ç†å·¥å…·
â”‚   â”œâ”€â”€ App.vue               # æ ¹ç»„ä»¶ï¼ˆä»…è´Ÿè´£å¼•å…¥Editor.vueï¼‰
â”‚   â”œâ”€â”€ Editor.vue            # ä¸»ç¼–è¾‘å™¨ç»„ä»¶ï¼ˆåŒ…å«å…¨éƒ¨ä¸šåŠ¡ä¸UIï¼‰
â”‚   â”œâ”€â”€ main.js               # åº”ç”¨å…¥å£
â”‚   â””â”€â”€ style.css             # å…¨å±€æ ·å¼
â”œâ”€â”€ .gitignore                # Git å¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ index.html                # HTML æ¨¡æ¿
â”œâ”€â”€ package.json              # é¡¹ç›®é…ç½®
â”œâ”€â”€ package-lock.json         # ä¾èµ–é”å®š
â”œâ”€â”€ vite.config.js            # Vite é…ç½®
â””â”€â”€ README.md                 # é¡¹ç›®è¯´æ˜
```

**æ³¨æ„ï¼š**
- vite.config.jsä¸­ï¼Œé…ç½®vite-plugin-static-copyï¼ŒæŠŠå‡ ä¸ªjsåº“çš„å¤åˆ¶åˆ°ç›®æ ‡è·¯å¾„ï¼š
  > å¦‚éœ€åŠ è½½Dracoå‹ç¼©çš„glTFæ¨¡å‹ï¼Œè¯·å°†node_modules/three/examples/jsm/libs/draco/ç›®å½•ä¸­çš„æ–‡ä»¶å¤åˆ¶åˆ° /draco/ ç›®å½•ä¸‹ã€‚
  > å¦‚éœ€åŠ è½½KTX2çº¹ç†ï¼Œè¯·å°†node_modules/three/examples/jsm/libs/basisç›®å½•ä¸­çš„æ–‡ä»¶æ”¾å…¥ /basis/ ç›®å½•ä¸‹ã€‚
  > å¦‚éœ€åŠ è½½Meshoptå‹ç¼©çš„glTFæ¨¡å‹ï¼Œè¯·å°†node_modules/three/examples/jsm/libs/meshopt_decoder.module.jsæ–‡ä»¶æ”¾å…¥ public/meshopt/ ç›®å½•ä¸‹ã€‚


## ğŸ¯ ä¸»è¦åŠŸèƒ½

- **3Dåœºæ™¯æ¸²æŸ“**: åŸºäº Three.js çš„é«˜æ€§èƒ½ 3D æ¸²æŸ“
- **å‡ ä½•ä½“åˆ›å»º**: æ”¯æŒå¤šç§åŸºç¡€å’Œæ‰©å±•å‡ ä½•ä½“åˆ›å»º
  - åŸºç¡€å‡ ä½•ä½“: ç«‹æ–¹ä½“ã€çƒä½“ã€åœ†æŸ±ä½“ã€å¹³é¢ã€åœ†é”¥ä½“ã€åœ†ç¯ä½“
  - æ‰©å±•å‡ ä½•ä½“: åäºŒé¢ä½“ã€äºŒåé¢ä½“ã€å…«é¢ä½“ã€å››é¢ä½“ã€ç¯å½¢ã€ç®¡é“
  - ç¯å…‰å¯¹è±¡: æ–¹å‘å…‰ã€ç‚¹å…‰æºã€èšå…‰ç¯ã€ç¯å¢ƒå…‰ã€åŠçƒå…‰
  - å…¶ä»–å¯¹è±¡: ç›¸æœºã€ç©ºå¯¹è±¡ã€æ–‡æœ¬ã€ç²¾çµ
- **æ¨¡å‹ç®¡ç†**: æ”¯æŒå¤šç§ 3D æ¨¡å‹æ ¼å¼çš„å¯¼å…¥å’Œç®¡ç†
- **äº¤äº’æ“ä½œ**: 
  - èµ„æºæµè§ˆå™¨ä¸­ç›´æ¥æ·»åŠ å‡ ä½•ä½“
  - å®æ—¶å˜æ¢æ“ä½œ (ä½ç§»ã€æ—‹è½¬ã€ç¼©æ”¾)
  - å•å¯¹è±¡é€‰æ‹©å’Œç¼–è¾‘ï¼ˆå¤šé€‰ã€æ¡†é€‰åŠŸèƒ½å·²ç§»é™¤ï¼Œä»…æ”¯æŒå•é€‰ï¼‰
- **å±æ€§ç¼–è¾‘**: å®æ—¶ä¿®æ”¹æ¨¡å‹çš„æè´¨ã€å‡ ä½•ä½“ç­‰å±æ€§
- **åœºæ™¯ç®¡ç†**: å®Œæ•´çš„åœºæ™¯å±‚çº§ç®¡ç†å’Œåºåˆ—åŒ–
- **èµ„æºæµè§ˆ**: å†…ç½®èµ„æºç®¡ç†å™¨ï¼Œæ”¯æŒæ¨¡å‹é¢„è§ˆå’Œå‡ ä½•ä½“åˆ›å»º
- **åå¤„ç†æœºåˆ¶**: 
  - é›†æˆäº†Three.js EffectComposeråå¤„ç†æ¡†æ¶ï¼Œæ”¯æŒå¤šç§åå¤„ç†æ•ˆæœé“¾è·¯ï¼ˆå¦‚Bloomã€FXAAç­‰ï¼‰ã€‚
  - æä¾›ç»Ÿä¸€APIï¼Œå¯åŠ¨æ€æ·»åŠ ã€ç§»é™¤ã€è°ƒæ•´å„ç±»Passã€‚
  - ä¸»è¦APIï¼š
    - `scene.sceneManager.addPass(pass, index)`ï¼šæ·»åŠ æŒ‡å®šPassåˆ°åå¤„ç†é“¾ï¼ˆå¯æŒ‡å®šæ’å…¥é¡ºåºï¼‰ã€‚
    - `scene.sceneManager.removePass(pass)`ï¼šç§»é™¤æŒ‡å®šPassã€‚
    - `scene.sceneManager.setPassParams(pass, params)`ï¼šæ‰¹é‡ä¿®æ”¹Passå‚æ•°ã€‚
  - é»˜è®¤å·²é›†æˆRenderPassï¼Œä¸šåŠ¡å±‚å¯é€šè¿‡`scene.sceneManager.addPass(...)`ç­‰æ–¹æ³•çµæ´»æ‰©å±•åå¤„ç†æ•ˆæœã€‚

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### ç»„ä»¶å±‚æ¬¡

1. **UI å±‚** (`components/editor/`): è´Ÿè´£ç”¨æˆ·ç•Œé¢å’Œäº¤äº’
2. **ä¸»ç¼–è¾‘å™¨ç»„ä»¶** (`Editor.vue`): è´Ÿè´£æ‰€æœ‰ä¸šåŠ¡é€»è¾‘å’ŒUIçš„é›†æˆ
3. **3D æ¸²æŸ“å±‚** (`components/scene/`): å¤„ç† 3D åœºæ™¯æ¸²æŸ“å’Œæ˜¾ç¤º
4. **é€»è¾‘å±‚** (`composables/`, `core/`): ä¸šåŠ¡é€»è¾‘å’ŒçŠ¶æ€ç®¡ç†
5. **APIå±‚** (`api/`): æ•°æ®è¯·æ±‚å’Œå¤–éƒ¨æ¥å£
6. **å·¥å…·å±‚** (`utils/`): é€šç”¨å·¥å…·å‡½æ•°

### æŠ€æœ¯ç‰¹ç‚¹

- **å“åº”å¼çŠ¶æ€**: ä½¿ç”¨ Vue 3 Composition API ç®¡ç†åº”ç”¨çŠ¶æ€
- **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„ä»£ç ç»„ç»‡å’ŒèŒè´£åˆ†ç¦»
- **ç±»å‹å®‰å…¨**: è‰¯å¥½çš„ä»£ç ç»“æ„æ”¯æŒ TypeScript è¿ç§»
- **æ€§èƒ½ä¼˜åŒ–**: åˆç†çš„ç»„ä»¶æ‡’åŠ è½½å’Œæ¸²æŸ“ä¼˜åŒ–

## ğŸ“‹ å¼€å‘è§„èŒƒ

- éµå¾ª Vue 3 ç»„åˆå¼ API æœ€ä½³å®è·µ
- ä½¿ç”¨ ES6+ è¯­æ³•ç‰¹æ€§
- ç»„ä»¶å‘½åé‡‡ç”¨ PascalCase
- æ–‡ä»¶å’Œç›®å½•å‘½åé‡‡ç”¨ camelCase
- Git æäº¤ä¿¡æ¯æ ¼å¼: `feat: åŠŸèƒ½æè¿°`

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2

# VSCode Open Tabs
(No open tabs)

# Current Time
2025/8/6 ä¸Šåˆ10:55:13 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
149 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. README.md å·²ç¡®è®¤é¡¹ç›®åå¤„ç†æœºåˆ¶åŸºäº Three.js EffectComposerï¼Œä¸” SceneManager æä¾› addPass/removePass/setPassParams ç­‰ç»Ÿä¸€ APIã€‚
2. éœ€æŸ¥çœ‹ useObjectSelection.jsï¼Œåˆ†æå½“å‰é«˜äº®å®ç°ï¼ˆæè´¨å˜æ›´ï¼‰ï¼Œå¹¶ç¡®å®šå¦‚ä½•åˆ‡æ¢ä¸º OutlinePassã€‚
3. éœ€æŸ¥æ‰¾ SceneManager.jsï¼Œç¡®è®¤åå¤„ç†é“¾è·¯å’Œ addPass çš„å…·ä½“å®ç°ï¼Œä¾¿äºæ­£ç¡®æ’å…¥ OutlinePassã€‚
4. å…ˆæŸ¥çœ‹ useObjectSelection.jsï¼Œç†è§£é€‰ä¸­å¯¹è±¡é«˜äº®çš„ç°æœ‰é€»è¾‘ã€‚
</thinking>

<read_file>
<path>src/composables/useObjectSelection.js</path>
</read_file>

---

**User:**

[read_file for 'src/composables/useObjectSelection.js'] Result:
/**
 * å¯¹è±¡é€‰æ‹©ç®¡ç† Composable
 * æä¾›å¯¹è±¡é€‰æ‹©ç›¸å…³çš„å“åº”å¼çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // å“åº”å¼çŠ¶æ€
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // é€‰æ‹©æ¨¡å¼
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // æ¡†é€‰çŠ¶æ€
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // é€‰æ‹©é…ç½®
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // æ‚¬åœçŠ¶æ€
  const hoveredObject = ref(null);
  
  /**
   * é€‰æ‹©å•ä¸ªå¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * é€‰æ‹©å¤šä¸ªå¯¹è±¡
   * @param {string[]|THREE.Object3D[]} objects å¯¹è±¡æ•°ç»„
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * å–æ¶ˆé€‰æ‹©å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * æ¸…ç©ºé€‰æ‹©
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * åˆ‡æ¢å¯¹è±¡é€‰æ‹©çŠ¶æ€
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * å…¨é€‰å¯¹è±¡
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * åé€‰å¯¹è±¡
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®ç±»å‹é€‰æ‹©å¯¹è±¡
   * @param {string} type å¯¹è±¡ç±»å‹
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®åç§°é€‰æ‹©å¯¹è±¡
   * @param {string} name å¯¹è±¡åç§°
   * @param {boolean} exactMatch æ˜¯å¦ç²¾ç¡®åŒ¹é…
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * å¤„ç†é¼ æ ‡ç‚¹å‡»é€‰æ‹©
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // ç‚¹å‡»ç©ºç™½åŒºåŸŸï¼Œæ¸…ç©ºé€‰æ‹©
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * å¤„ç†é¼ æ ‡æ‚¬åœ
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // æ·»åŠ æ–°çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * å¼€å§‹æ¡†é€‰
   * @param {number} x èµ·å§‹Xåæ ‡
   * @param {number} y èµ·å§‹Yåæ ‡
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * æ›´æ–°æ¡†é€‰
   * @param {number} x å½“å‰Xåæ ‡
   * @param {number} y å½“å‰Yåæ ‡
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * ç»“æŸæ¡†é€‰
   * @param {THREE.Camera} camera ç›¸æœº
   * @param {HTMLElement} element æ¸²æŸ“å…ƒç´ 
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // è®¡ç®—æ¡†é€‰åŒºåŸŸ
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // æ£€æŸ¥æ¯ä¸ªå¯¹è±¡æ˜¯å¦åœ¨æ¡†é€‰åŒºåŸŸå†…
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®
   */
  function updateSelectionHighlights() {
    if (!selectionConfig.highlightSelected) return;
    
    // ç§»é™¤æ‰€æœ‰é«˜äº®
    objectManager.getAllObjects().forEach(object => {
      removeSelectionHighlight(object);
    });
    
    // ä¸ºé€‰ä¸­çš„å¯¹è±¡æ·»åŠ é«˜äº®
    selectedObjects.value.forEach(object => {
      addSelectionHighlight(object);
    });
  }
  
  /**
   * æ·»åŠ é€‰æ‹©é«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºé«˜äº®æè´¨å¹¶è®°å½•
        if (!child.userData.selectionMaterial) {
          const highlightMaterial = child.material.clone();
          highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
          highlightMaterial.emissiveIntensity = 0.3;
          child.userData.selectionMaterial = highlightMaterial;
        }
        child.material = child.userData.selectionMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤é€‰æ‹©é«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
          delete child.userData.originalMaterial;
        }
        if (child.userData.selectionMaterial) {
          delete child.userData.selectionMaterial;
        }
      }
    });
  }
  
  /**
   * æ·»åŠ æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºæ‚¬åœæè´¨å¹¶è®°å½•
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // å¦‚æœå¯¹è±¡è¢«é€‰ä¸­ï¼Œæ¢å¤ selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
  
  /**
   * è·å–é€‰æ‹©è¾¹ç•Œæ¡†
   * @returns {THREE.Box3|null} è¾¹ç•Œæ¡†
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * è·å–é€‰æ‹©ä¸­å¿ƒç‚¹
   * @returns {THREE.Vector3|null} ä¸­å¿ƒç‚¹
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // ç›‘å¬é€‰æ‹©å˜åŒ–
  watch(selectedObjects, (newSelection, oldSelection) => {
    // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘é€‰æ‹©å˜åŒ–äº‹ä»¶
  });
  
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    
    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2

# VSCode Open Tabs
(No open tabs)

# Current Time
2025/8/6 ä¸Šåˆ10:55:18 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
159 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. useObjectSelection.js å½“å‰é€šè¿‡ä¿®æ”¹æè´¨å®ç°é«˜äº®ï¼Œéœ€æ”¹ä¸ºé€šè¿‡ OutlinePass å®ç°è½®å»“é«˜äº®ã€‚
2. éœ€åœ¨åå¤„ç†é“¾ä¸­åŠ¨æ€æ’å…¥/ç§»é™¤ OutlinePassï¼Œå¹¶å°†é€‰ä¸­å¯¹è±¡ä¼ é€’ç»™ OutlinePass.selectedObjectsã€‚
3. éœ€æŸ¥çœ‹ SceneManager.jsï¼Œç¡®è®¤åå¤„ç†é“¾ï¼ˆEffectComposerï¼‰å’Œ addPass/removePass çš„å…·ä½“å®ç°ï¼Œç¡®ä¿ OutlinePass èƒ½æ­£ç¡®é›†æˆã€‚
4. å…ˆæŸ¥çœ‹ src/core/SceneManager.jsï¼Œåˆ†æåå¤„ç†ç›¸å…³å®ç°ã€‚
</thinking>

<read_file>
<path>src/core/SceneManager.js</path>
</read_file>

---

**User:**

[read_file for 'src/core/SceneManager.js'] Result:
/**
 * åœºæ™¯ç®¡ç†å™¨
 * è´Ÿè´£Three.jsåœºæ™¯çš„åˆ›å»ºã€ç®¡ç†å’Œæ¸²æŸ“
 */

import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { reactive } from 'vue';

class SceneManager {
  constructor() {
    this.scene = null;
    this.renderer = null;
    this.camera = null;
    this.controls = null;
    this.container = null;
    this.animationId = null;

    // åå¤„ç†
    this.composer = null;
    this.passes = [];

    // å“åº”å¼çŠ¶æ€
    this.state = reactive({
      isInitialized: false,
      isRendering: false,
      frameCount: 0,
      fps: 0
    });
    
    // æ€§èƒ½ç›‘æ§
    this.lastTime = 0;
    this.frameCount = 0;
    
    // äº‹ä»¶ç›‘å¬å™¨
    this.resizeHandler = this.handleResize.bind(this);
    
    this.init();
  }
  
  /**
   * åˆå§‹åŒ–åœºæ™¯
   */
  init() {
    this.createScene();
    this.createRenderer();
    this.createCamera();
    this.setupLights();

    // åˆå§‹åŒ–åå¤„ç†
    this.initComposer();

    this.state.isInitialized = true;
  }
  
  /**
   * åˆ›å»ºåœºæ™¯
   */
  createScene() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x222222);
    this.scene.fog = new THREE.Fog(0x222222, 1000, 10000);
  }
  
  /**
   * åˆ›å»ºæ¸²æŸ“å™¨
   */
  createRenderer() {
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });

    this.renderer.setSize(800, 600);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1;
  }

  /**
   * åˆå§‹åŒ–åå¤„ç†
   */
  initComposer() {
    if (this.renderer && this.scene && this.camera) {
      this.composer = new EffectComposer(this.renderer);
      const renderPass = new RenderPass(this.scene, this.camera);
      this.composer.addPass(renderPass);
      this.passes = [renderPass];
    }
  }

  /**
   * æ·»åŠ åå¤„ç†Pass
   * @param {Pass} pass
   * @param {number} index
   */
  addPass(pass, index) {
    if (!this.composer) return;
    if (typeof index === 'number' && index >= 0 && index < this.composer.passes.length) {
      this.composer.passes.splice(index, 0, pass);
      this.composer.addPass(pass);
      this.passes.splice(index, 0, pass);
    } else {
      this.composer.addPass(pass);
      this.passes.push(pass);
    }
  }

  /**
   * ç§»é™¤åå¤„ç†Pass
   * @param {Pass} pass
   */
  removePass(pass) {
    if (!this.composer) return;
    const idx = this.composer.passes.indexOf(pass);
    if (idx > -1) {
      this.composer.passes.splice(idx, 1);
      this.passes.splice(idx, 1);
    }
  }

  /**
   * ä¿®æ”¹æŒ‡å®šPasså‚æ•°
   * @param {Pass} pass
   * @param {object} params
   */
  setPassParams(pass, params) {
    if (!pass || !params) return;
    Object.entries(params).forEach(([key, value]) => {
      if (key in pass) {
        pass[key] = value;
      }
    });
  }
  
  /**
   * åˆ›å»ºç›¸æœº
   */
  createCamera() {
    this.camera = new THREE.PerspectiveCamera(
      75, // fov
      800 / 600, // aspect
      0.1, // near
      1000 // far
    );
    
    this.camera.position.set(5, 5, 5);
    this.camera.lookAt(0, 0, 0);
  }
  
  /**
   * è®¾ç½®å…‰ç…§
   */
  setupLights() {
    // ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    this.scene.add(ambientLight);
    
    // æ–¹å‘å…‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    this.scene.add(directionalLight);
    
    // ç‚¹å…‰æº
    const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
    pointLight.position.set(-20, 20, 20);
    pointLight.castShadow = true;
    this.scene.add(pointLight);
    
    // æ·»åŠ ç½‘æ ¼åœ°é¢
    this.setupGrid();
  }
  
  /**
   * è®¾ç½®ç½‘æ ¼åœ°é¢
   */
  setupGrid() {
    // åªåˆ›å»ºä¸€æ¬¡
    if (!this.gridHelper) {
      this.gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
      this.gridHelper.name = 'grid_helper';
      this.scene.add(this.gridHelper);
    }
    // æ·»åŠ åæ ‡è½´
    if (!this.axesHelper) {
      this.axesHelper = new THREE.AxesHelper(5);
      this.axesHelper.name = 'axes_helper';
      this.scene.add(this.axesHelper);
    }
  }

  /**
   * æ§åˆ¶ç½‘æ ¼å’Œåæ ‡è½´æ˜¾ç¤º/éšè—
   * @param {boolean} visible
   */
  setGridVisible(visible) {
    if (this.gridHelper) {
      this.gridHelper.visible = visible;
    }
    if (this.axesHelper) {
      this.axesHelper.visible = visible;
    }
  }
  
  /**
   * è®¾ç½®å®¹å™¨
   * @param {HTMLElement} container DOMå®¹å™¨
   */
  setContainer(container) {
    this.container = container;
    if (container && this.renderer) {
      container.appendChild(this.renderer.domElement);
      this.setupControls();
      this.handleResize();
      window.addEventListener('resize', this.resizeHandler);
    }
  }
  
  /**
   * è®¾ç½®OrbitControls
   */
  setupControls() {
    if (!this.camera || !this.renderer) return;
    
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    
    // é…ç½®æ§åˆ¶å™¨
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.screenSpacePanning = false;
    this.controls.minDistance = 1;
    this.controls.maxDistance = 500;
    this.controls.maxPolarAngle = Math.PI;
    
    // è®¾ç½®æ§åˆ¶å™¨é€Ÿåº¦
    this.controls.rotateSpeed = 1.0;
    this.controls.zoomSpeed = 1.0;
    this.controls.panSpeed = 1.0;
    
    // è®¾ç½®ç›®æ ‡ç‚¹
    this.controls.target.set(0, 0, 0);
    this.controls.update();
  }
  
  /**
   * æ›´æ–°æ§åˆ¶å™¨é…ç½®
   * @param {object} config æ§åˆ¶å™¨é…ç½®
   */
  updateControlsConfig(config) {
    if (!this.controls) return;
    
    Object.entries(config).forEach(([key, value]) => {
      if (this.controls.hasOwnProperty(key)) {
        this.controls[key] = value;
      }
    });
    
    this.controls.update();
  }
  
  /**
   * å¤„ç†çª—å£å¤§å°å˜åŒ–
   */
  handleResize() {
    if (!this.container || !this.renderer || !this.camera) return;

    const width = this.container.clientWidth;
    const height = this.container.clientHeight;

    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();

    this.renderer.setSize(width, height);
    if (this.composer) {
      this.composer.setSize(width, height);
    }
  }
  
  /**
   * å¼€å§‹æ¸²æŸ“å¾ªç¯
   */
  startRender() {
    if (this.state.isRendering) return;
    
    this.state.isRendering = true;
    this.lastTime = performance.now();
    this.animate();
  }
  
  /**
   * åœæ­¢æ¸²æŸ“å¾ªç¯
   */
  stopRender() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    this.state.isRendering = false;
  }
  
  /**
   * åŠ¨ç”»å¾ªç¯
   */
  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());
    
    // è®¡ç®—FPS
    const currentTime = performance.now();
    this.frameCount++;
    
    if (currentTime - this.lastTime >= 1000) {
      this.state.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
      this.frameCount = 0;
      this.lastTime = currentTime;
    }
    
    this.render();
    this.state.frameCount++;
  }
  
  /**
   * æ¸²æŸ“åœºæ™¯
   */
  render() {
    // æ›´æ–°æ§åˆ¶å™¨ï¼ˆå¯ç”¨é˜»å°¼æ—¶éœ€è¦ï¼‰
    if (this.controls) {
      this.controls.update();
    }

    if (this.composer) {
      this.composer.render();
    } else if (this.renderer && this.scene && this.camera) {
      this.renderer.render(this.scene, this.camera);
    }
  }
  
  /**
   * æ·»åŠ å¯¹è±¡åˆ°åœºæ™¯
   * @param {THREE.Object3D} object 3Då¯¹è±¡
   */
  addObject(object) {
    this.scene.add(object);
  }
  
  /**
   * ä»åœºæ™¯ç§»é™¤å¯¹è±¡
   * @param {THREE.Object3D} object 3Då¯¹è±¡
   */
  removeObject(object) {
    console.log('Removing object:', object);
    console.log(this.scene.children.includes);
    let idx = this.scene.children.findIndex(child => child === object || child.uuid === object.uuid);
    console.log('Removing object:', idx);
    if (idx > -1) {
      this.scene.remove(object);
      
      let idx2 = this.scene.children.findIndex(child => child === object || child.uuid === object.uuid);
      // å¦‚æœå¸¸è§„ç§»é™¤å¤±è´¥ï¼Œå°è¯•å¼ºåˆ¶ç§»é™¤
      if (idx2 > -1) {
          this.scene.children.splice(idx2, 1);
      }
    }
  }
  
  /**
   * æ¸…ç©ºåœºæ™¯
   */
  clearScene() {
    while (this.scene.children.length > 0) {
      const child = this.scene.children[0];
      this.scene.remove(child);
      
      // æ¸…ç†å‡ ä½•ä½“å’Œæè´¨
      if (child.geometry) {
        child.geometry.dispose();
      }
      if (child.material) {
        if (Array.isArray(child.material)) {
          child.material.forEach(material => material.dispose());
        } else {
          child.material.dispose();
        }
      }
    }
    
    // é‡æ–°è®¾ç½®å…‰ç…§
    this.setupLights();
  }
  
  /**
   * è®¾ç½®åœºæ™¯èƒŒæ™¯
   * @param {THREE.Color|THREE.Texture} background èƒŒæ™¯
   */
  setBackground(background) {
    this.scene.background = background;
  }
  
  /**
   * è·å–åœºæ™¯å¯¹è±¡åˆ—è¡¨
   * @returns {THREE.Object3D[]} å¯¹è±¡åˆ—è¡¨
   */
  getObjects() {
    return this.scene.children.filter(child => 
      !(child instanceof THREE.Light) && 
      !(child instanceof THREE.Camera)
    );
  }
  
  /**
   * æ ¹æ®åç§°æŸ¥æ‰¾å¯¹è±¡
   * @param {string} name å¯¹è±¡åç§°
   * @returns {THREE.Object3D|null} æ‰¾åˆ°çš„å¯¹è±¡
   */
  findObjectByName(name) {
    return this.scene.getObjectByName(name);
  }
  
  /**
   * å¯¼å‡ºåœºæ™¯æ•°æ®
   * @returns {object} åœºæ™¯æ•°æ®
   */
  exportScene() {
    const sceneData = {
      objects: [],
      lights: [],
      camera: {
        position: this.camera.position.toArray(),
        rotation: this.camera.rotation.toArray(),
        fov: this.camera.fov,
        near: this.camera.near,
        far: this.camera.far
      },
      background: this.scene.background instanceof THREE.Color ? 
        this.scene.background.getHex() : null
    };
    
    this.scene.children.forEach(child => {
      if (child instanceof THREE.Light) {
        sceneData.lights.push({
          type: child.type,
          position: child.position.toArray(),
          color: child.color.getHex(),
          intensity: child.intensity
        });
      } else if (!(child instanceof THREE.Camera)) {
        sceneData.objects.push({
          name: child.name,
          type: child.type,
          position: child.position.toArray(),
          rotation: child.rotation.toArray(),
          scale: child.scale.toArray()
        });
      }
    });
    
    return sceneData;
  }
  
  /**
   * é”€æ¯åœºæ™¯ç®¡ç†å™¨
   */
  dispose() {
    this.stopRender();
    
    if (this.container && this.resizeHandler) {
      window.removeEventListener('resize', this.resizeHandler);
    }
    
    // æ¸…ç†æ§åˆ¶å™¨
    if (this.controls) {
      this.controls.dispose();
      this.controls = null;
    }
    
    this.clearScene();

    if (this.composer) {
      this.composer = null;
      this.passes = [];
    }

    if (this.renderer) {
      this.renderer.dispose();
    }
  }
}

// å•ä¾‹æ¨¡å¼
let instance = null;

export function useSceneManager() {
  if (!instance) {
    instance = new SceneManager();
  }
  return instance;
}

export default SceneManager;

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2

# VSCode Open Tabs
(No open tabs)

# Current Time
2025/8/6 ä¸Šåˆ10:55:22 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
161 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. SceneManager å·²å°è£… EffectComposerï¼Œæ”¯æŒ addPass/removePassï¼Œå¯ç›´æ¥æ’å…¥ OutlinePassã€‚
2. useObjectSelection.js éœ€ç§»é™¤æè´¨é«˜äº®ç›¸å…³é€»è¾‘ï¼Œæ”¹ä¸ºç®¡ç† OutlinePass çš„ selectedObjectsã€‚
3. éœ€åœ¨ useObjectSelection.js ä¸­å¼•å…¥ OutlinePassï¼Œé€‰ä¸­å¯¹è±¡å˜åŒ–æ—¶åŒæ­¥ OutlinePass.selectedObjectsã€‚
4. éœ€åœ¨é¦–æ¬¡é€‰ä¸­å¯¹è±¡æ—¶è‡ªåŠ¨æ·»åŠ  OutlinePassï¼Œæœªé€‰ä¸­æ—¶ç§»é™¤ã€‚
5. éœ€åœ¨ package.json æ£€æŸ¥ three/examples/jsm/postprocessing/OutlinePass æ˜¯å¦å·²ä¾èµ–ï¼Œè‹¥æ— éœ€æé†’ç”¨æˆ·å®‰è£… threeã€‚
6. å…ˆæŸ¥çœ‹ package.jsonï¼Œç¡®è®¤ three ä¾èµ–ã€‚
</thinking>

<read_file>
<path>package.json</path>
</read_file>

---

**User:**

[read_file for 'package.json'] Result:
{
  "name": "three-editor-by-ai",
  "description": "A 3D editor built with Three.js and Vue.js, powered by AI",
  "private": false,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "dayjs": "^1.11.13",
    "lodash": "^4.17.21",
    "three": "^0.179.1",
    "vue": "^3.5.17"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.0",
    "vite": "^7.0.4",
    "vite-plugin-static-copy": "^3.1.1"
  }
}

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2

# VSCode Open Tabs
(No open tabs)

# Current Time
2025/8/6 ä¸Šåˆ10:55:28 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
196 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
three å·²åœ¨ä¾èµ–ä¸­ï¼Œæ— éœ€é¢å¤–å®‰è£… OutlinePass ç›¸å…³ä¾èµ–ã€‚  
ä¸‹ä¸€æ­¥ï¼šä¿®æ”¹ useObjectSelection.jsï¼Œç§»é™¤æè´¨é«˜äº®ç›¸å…³æ–¹æ³•ï¼ˆaddSelectionHighlight/removeSelectionHighlightï¼‰ï¼Œæ”¹ä¸ºï¼š
- å¼•å…¥ OutlinePassï¼Œå¹¶åœ¨é€‰ä¸­å¯¹è±¡å˜åŒ–æ—¶ï¼ŒåŠ¨æ€è®¾ç½® OutlinePass.selectedObjectsã€‚
- é€‰ä¸­å¯¹è±¡éç©ºæ—¶è‡ªåŠ¨æ·»åŠ  OutlinePass åˆ° SceneManager åå¤„ç†é“¾ï¼Œæ— é€‰ä¸­æ—¶ç§»é™¤ã€‚
- éœ€ä¿è¯ OutlinePass åªåˆ›å»ºä¸€æ¬¡ï¼Œä¸”å‚æ•°ï¼ˆå¦‚ edgeStrengthã€edgeGlowã€edgeThicknessã€visibleEdgeColorã€hiddenEdgeColorï¼‰å¯é…ç½®ã€‚
- éœ€åœ¨ README.md é¡¹ç›®ç»“æ„ä¸­æ–°å¢ OutlinePass ç›¸å…³è¯´æ˜ã€‚

å…ˆå®ç° useObjectSelection.js çš„æ ¸å¿ƒæ›¿æ¢é€»è¾‘ã€‚
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useObjectSelection() {
=======
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';
import { useSceneManager } from '../core/SceneManager.js';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';

export function useObjectSelection() {
+++++++ REPLACE

------- SEARCH
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // å“åº”å¼çŠ¶æ€
=======
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  const sceneManager = useSceneManager();

  // OutlinePass å®ä¾‹
  let outlinePass = null;

  // OutlinePass é…ç½®
  const outlineConfig = reactive({
    edgeStrength: 3.0,
    edgeGlow: 0.0,
    edgeThickness: 2.0,
    pulsePeriod: 0,
    visibleEdgeColor: 0x00ff00,
    hiddenEdgeColor: 0x000000
  });

  // å“åº”å¼çŠ¶æ€
+++++++ REPLACE

------- SEARCH
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®
   */
  function updateSelectionHighlights() {
    if (!selectionConfig.highlightSelected) return;
    
    // ç§»é™¤æ‰€æœ‰é«˜äº®
    objectManager.getAllObjects().forEach(object => {
      removeSelectionHighlight(object);
    });
    
    // ä¸ºé€‰ä¸­çš„å¯¹è±¡æ·»åŠ é«˜äº®
    selectedObjects.value.forEach(object => {
      addSelectionHighlight(object);
    });
  }
  
  /**
   * æ·»åŠ é€‰æ‹©é«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºé«˜äº®æè´¨å¹¶è®°å½•
        if (!child.userData.selectionMaterial) {
          const highlightMaterial = child.material.clone();
          highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
          highlightMaterial.emissiveIntensity = 0.3;
          child.userData.selectionMaterial = highlightMaterial;
        }
        child.material = child.userData.selectionMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤é€‰æ‹©é«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
          delete child.userData.originalMaterial;
        }
        if (child.userData.selectionMaterial) {
          delete child.userData.selectionMaterial;
        }
      }
    });
  }
=======
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®ï¼ˆè½®å»“é«˜äº®ï¼‰
   */
  function updateSelectionHighlights() {
    // åªå¤„ç†è½®å»“é«˜äº®
    if (!selectionConfig.highlightSelected) {
      removeOutlinePass();
      return;
    }
    const selected = selectedObjects.value.filter(obj => !!obj);
    if (selected.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(selected);
  }

  /**
   * æ·»åŠ æˆ–æ›´æ–° OutlinePass
   * @param {THREE.Object3D[]} objects
   */
  function addOrUpdateOutlinePass(objects) {
    if (!sceneManager.composer || !sceneManager.scene || !sceneManager.camera) return;
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.width,
          sceneManager.renderer.domElement.height
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
  }

  /**
   * ç§»é™¤ OutlinePass
   */
  function removeOutlinePass() {
    if (outlinePass && sceneManager.composer) {
      sceneManager.removePass(outlinePass);
      outlinePass = null;
    }
  }
+++++++ REPLACE

------- SEARCH
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    
    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}
=======
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    outlineConfig,

    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The content was successfully saved to src/composables/useObjectSelection.js.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/composables/useObjectSelection.js">
/**
 * å¯¹è±¡é€‰æ‹©ç®¡ç† Composable
 * æä¾›å¯¹è±¡é€‰æ‹©ç›¸å…³çš„å“åº”å¼çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';
import { useSceneManager } from '../core/SceneManager.js';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  const sceneManager = useSceneManager();

  // OutlinePass å®ä¾‹
  let outlinePass = null;

  // OutlinePass é…ç½®
  const outlineConfig = reactive({
    edgeStrength: 3.0,
    edgeGlow: 0.0,
    edgeThickness: 2.0,
    pulsePeriod: 0,
    visibleEdgeColor: 0x00ff00,
    hiddenEdgeColor: 0x000000
  });

  // å“åº”å¼çŠ¶æ€
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // é€‰æ‹©æ¨¡å¼
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // æ¡†é€‰çŠ¶æ€
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // é€‰æ‹©é…ç½®
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // æ‚¬åœçŠ¶æ€
  const hoveredObject = ref(null);
  
  /**
   * é€‰æ‹©å•ä¸ªå¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * é€‰æ‹©å¤šä¸ªå¯¹è±¡
   * @param {string[]|THREE.Object3D[]} objects å¯¹è±¡æ•°ç»„
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * å–æ¶ˆé€‰æ‹©å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * æ¸…ç©ºé€‰æ‹©
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * åˆ‡æ¢å¯¹è±¡é€‰æ‹©çŠ¶æ€
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * å…¨é€‰å¯¹è±¡
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * åé€‰å¯¹è±¡
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®ç±»å‹é€‰æ‹©å¯¹è±¡
   * @param {string} type å¯¹è±¡ç±»å‹
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®åç§°é€‰æ‹©å¯¹è±¡
   * @param {string} name å¯¹è±¡åç§°
   * @param {boolean} exactMatch æ˜¯å¦ç²¾ç¡®åŒ¹é…
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * å¤„ç†é¼ æ ‡ç‚¹å‡»é€‰æ‹©
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // ç‚¹å‡»ç©ºç™½åŒºåŸŸï¼Œæ¸…ç©ºé€‰æ‹©
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * å¤„ç†é¼ æ ‡æ‚¬åœ
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // æ·»åŠ æ–°çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * å¼€å§‹æ¡†é€‰
   * @param {number} x èµ·å§‹Xåæ ‡
   * @param {number} y èµ·å§‹Yåæ ‡
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * æ›´æ–°æ¡†é€‰
   * @param {number} x å½“å‰Xåæ ‡
   * @param {number} y å½“å‰Yåæ ‡
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * ç»“æŸæ¡†é€‰
   * @param {THREE.Camera} camera ç›¸æœº
   * @param {HTMLElement} element æ¸²æŸ“å…ƒç´ 
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // è®¡ç®—æ¡†é€‰åŒºåŸŸ
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // æ£€æŸ¥æ¯ä¸ªå¯¹è±¡æ˜¯å¦åœ¨æ¡†é€‰åŒºåŸŸå†…
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®ï¼ˆè½®å»“é«˜äº®ï¼‰
   */
  function updateSelectionHighlights() {
    // åªå¤„ç†è½®å»“é«˜äº®
    if (!selectionConfig.highlightSelected) {
      removeOutlinePass();
      return;
    }
    const selected = selectedObjects.value.filter(obj => !!obj);
    if (selected.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(selected);
  }

  /**
   * æ·»åŠ æˆ–æ›´æ–° OutlinePass
   * @param {THREE.Object3D[]} objects
   */
  function addOrUpdateOutlinePass(objects) {
    if (!sceneManager.composer || !sceneManager.scene || !sceneManager.camera) return;
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.width,
          sceneManager.renderer.domElement.height
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
  }

  /**
   * ç§»é™¤ OutlinePass
   */
  function removeOutlinePass() {
    if (outlinePass && sceneManager.composer) {
      sceneManager.removePass(outlinePass);
      outlinePass = null;
    }
  }
  
  /**
   * æ·»åŠ æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºæ‚¬åœæè´¨å¹¶è®°å½•
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // å¦‚æœå¯¹è±¡è¢«é€‰ä¸­ï¼Œæ¢å¤ selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
  
  /**
   * è·å–é€‰æ‹©è¾¹ç•Œæ¡†
   * @returns {THREE.Box3|null} è¾¹ç•Œæ¡†
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * è·å–é€‰æ‹©ä¸­å¿ƒç‚¹
   * @returns {THREE.Vector3|null} ä¸­å¿ƒç‚¹
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // ç›‘å¬é€‰æ‹©å˜åŒ–
  watch(selectedObjects, (newSelection, oldSelection) => {
    // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘é€‰æ‹©å˜åŒ–äº‹ä»¶
  });
  
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    outlineConfig,

    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:55:48 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
1,491 / 111.452K tokens used (1%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. useObjectSelection.js å·²å®Œæˆè½®å»“é«˜äº®æ›¿æ¢ï¼Œä¸‹ä¸€æ­¥éœ€åœ¨ README.md é¡¹ç›®ç»“æ„å’ŒåŠŸèƒ½è¯´æ˜ä¸­è¡¥å…… OutlinePass é«˜äº®æœºåˆ¶è¯´æ˜ã€‚
2. éœ€åœ¨â€œåå¤„ç†æœºåˆ¶â€éƒ¨åˆ†è¯´æ˜æ”¯æŒé€‰ä¸­å¯¹è±¡è½®å»“é«˜äº®ï¼Œé¡¹ç›®ç»“æ„ä¸­å¯åœ¨ composables/ è¯´æ˜ useObjectSelection.js æ”¯æŒ OutlinePassã€‚
3. æŒ‰ .clinerules/ çº¦å®šï¼Œéœ€åŒæ­¥æ›´æ–° README.mdã€‚
</thinking>

<replace_in_file>
<path>README.md</path>
<diff>
------- SEARCH
â”‚   â”‚   â”œâ”€â”€ useObjectSelection.js  # å¯¹è±¡é€‰æ‹©
=======
â”‚   â”‚   â”œâ”€â”€ useObjectSelection.js  # å¯¹è±¡é€‰æ‹©ï¼ˆæ”¯æŒé€‰ä¸­å¯¹è±¡è½®å»“é«˜äº®ï¼Œé›†æˆOutlinePassï¼‰
+++++++ REPLACE

------- SEARCH
- **åå¤„ç†æœºåˆ¶**: 
  - é›†æˆäº†Three.js EffectComposeråå¤„ç†æ¡†æ¶ï¼Œæ”¯æŒå¤šç§åå¤„ç†æ•ˆæœé“¾è·¯ï¼ˆå¦‚Bloomã€FXAAç­‰ï¼‰ã€‚
  - æä¾›ç»Ÿä¸€APIï¼Œå¯åŠ¨æ€æ·»åŠ ã€ç§»é™¤ã€è°ƒæ•´å„ç±»Passã€‚
  - ä¸»è¦APIï¼š
    - `scene.sceneManager.addPass(pass, index)`ï¼šæ·»åŠ æŒ‡å®šPassåˆ°åå¤„ç†é“¾ï¼ˆå¯æŒ‡å®šæ’å…¥é¡ºåºï¼‰ã€‚
    - `scene.sceneManager.removePass(pass)`ï¼šç§»é™¤æŒ‡å®šPassã€‚
    - `scene.sceneManager.setPassParams(pass, params)`ï¼šæ‰¹é‡ä¿®æ”¹Passå‚æ•°ã€‚
  - é»˜è®¤å·²é›†æˆRenderPassï¼Œä¸šåŠ¡å±‚å¯é€šè¿‡`scene.sceneManager.addPass(...)`ç­‰æ–¹æ³•çµæ´»æ‰©å±•åå¤„ç†æ•ˆæœã€‚
=======
- **åå¤„ç†æœºåˆ¶**: 
  - é›†æˆäº†Three.js EffectComposeråå¤„ç†æ¡†æ¶ï¼Œæ”¯æŒå¤šç§åå¤„ç†æ•ˆæœé“¾è·¯ï¼ˆå¦‚Bloomã€FXAAã€OutlinePassç­‰ï¼‰ã€‚
  - æ”¯æŒé€‰ä¸­å¯¹è±¡è½®å»“é«˜äº®ï¼ˆOutlinePassï¼‰ï¼Œé€‰ä¸­å¯¹è±¡æ—¶è‡ªåŠ¨é«˜äº®å…¶è½®å»“ï¼Œæ€§èƒ½ä¼˜äºæè´¨æ›¿æ¢ã€‚
  - æä¾›ç»Ÿä¸€APIï¼Œå¯åŠ¨æ€æ·»åŠ ã€ç§»é™¤ã€è°ƒæ•´å„ç±»Passã€‚
  - ä¸»è¦APIï¼š
    - `scene.sceneManager.addPass(pass, index)`ï¼šæ·»åŠ æŒ‡å®šPassåˆ°åå¤„ç†é“¾ï¼ˆå¯æŒ‡å®šæ’å…¥é¡ºåºï¼‰ã€‚
    - `scene.sceneManager.removePass(pass)`ï¼šç§»é™¤æŒ‡å®šPassã€‚
    - `scene.sceneManager.setPassParams(pass, params)`ï¼šæ‰¹é‡ä¿®æ”¹Passå‚æ•°ã€‚
  - é»˜è®¤å·²é›†æˆRenderPassï¼Œä¸šåŠ¡å±‚å¯é€šè¿‡`scene.sceneManager.addPass(...)`ç­‰æ–¹æ³•çµæ´»æ‰©å±•åå¤„ç†æ•ˆæœã€‚
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'README.md'] Result:
The content was successfully saved to README.md.

Here is the full, updated content of the file that was saved:

<final_file_content path="README.md">
# 3D åœºæ™¯ç¼–è¾‘å™¨ (Three Editor by AI)

ä¸€ä¸ªåŸºäº Vue 3 + Three.js çš„ç°ä»£åŒ–3Dåœºæ™¯ç¼–è¾‘å™¨ï¼Œæ”¯æŒä¸‰ç»´æ¨¡å‹çš„æ‹–æ”¾ã€è°ƒæ•´å’Œå±æ€§é…ç½®ã€‚

## âœ… åŠŸèƒ½ä½“ç³»
- 3Dåœºæ™¯æ¸²æŸ“å’Œç®¡ç†
- å¤šç§åŸºç¡€å‡ ä½•ä½“åˆ›å»º
- å®Œæ•´çš„å¯¹è±¡å˜æ¢ç³»ç»Ÿï¼ˆç§»åŠ¨ã€æ—‹è½¬ã€ç¼©æ”¾ï¼‰
- å•é€‰ï¼ˆå¤šé€‰ã€æ¡†é€‰åŠŸèƒ½å·²ç§»é™¤ï¼Œä»…æ”¯æŒå•é€‰ï¼‰
- æ’¤é”€é‡åšå†å²è®°å½•
- 3Dæ¨¡å‹å’Œçº¹ç†åŠ è½½ï¼ˆGLTFã€OBJã€FBXç­‰æ ¼å¼ï¼‰
- æ‹–æ‹½ä¸Šä¼ å’Œèµ„æºç®¡ç†
- ç›¸æœºæ§åˆ¶å’Œé¢„è®¾è§†è§’
- æè´¨ç¼–è¾‘å’Œå±æ€§è°ƒæ•´
- åœºæ™¯åºåˆ—åŒ–å’Œå¯¼å…¥å¯¼å‡º

## ğŸš€ æŠ€æœ¯æ ˆ

- **å‰ç«¯æ¡†æ¶**: Vue 3 + Vite
- **3Då¼•æ“**: Three.js
- **æ„å»ºå·¥å…·**: Vite
- **ç½‘ç»œè¯·æ±‚**: Fetch API
- **å·¥å…·åº“**: 
  - Lodash - å®ç”¨å·¥å…·å‡½æ•°åº“
  - Day.js - è½»é‡çº§æ—¥æœŸæ—¶é—´åº“

## ğŸ“ é¡¹ç›®ç»“æ„

> 2025-08-05ï¼šToolbar.vue å·²ç§»é™¤â€œè®¾ç½®â€åˆ†ç»„åŠâ€œç½‘æ ¼å¸é™„ã€çº¿æ¡†æ¨¡å¼â€ç›¸å…³åŠŸèƒ½ã€‚

```
three-editor-by-ai/
â”œâ”€â”€ public/                     # é™æ€èµ„æº
â”‚   â””â”€â”€ vite.svg
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ assets/                 # é™æ€èµ„æº (3Dæ¨¡å‹ã€çº¹ç†ç­‰)
â”‚   â”‚   â””â”€â”€ vue.svg
â”‚   â”œâ”€â”€ components/             # Vue ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ editor/            # ç¼–è¾‘å™¨ UI ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ PropertyPanel.vue    # å±æ€§é¢æ¿
â”‚   â”‚   â”‚   â”œâ”€â”€ Toolbar.vue          # å·¥å…·æ 
â”‚   â”‚   â”‚   â”œâ”€â”€ AssetBrowser.vue     # èµ„æºæµè§ˆå™¨
â”‚   â”‚   â”‚   â””â”€â”€ Inspector.vue        # å¯¹è±¡æ£€æŸ¥å™¨
â”‚   â”‚   â”œâ”€â”€ scene/             # 3D åœºæ™¯ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ SceneViewer.vue      # ä¸»åœºæ™¯è§†å›¾
â”‚   â”‚   â”‚   â”œâ”€â”€ InteractionHints.vue     # æ“ä½œæç¤ºç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ ViewportControls.vue     # è§†å›¾æ§åˆ¶é¢æ¿ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ CubeViewportControls.vue # ç«‹æ–¹ä½“è§†è§’æ§ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ ObjectGizmo.vue      # å¯¹è±¡æ“ä½œæ§åˆ¶å™¨
â”‚   â”‚   â”‚   â””â”€â”€ Camera.vue           # ç›¸æœºæ§åˆ¶
â”‚   â”œâ”€â”€ composables/           # Vue Composition API å¯ç»„åˆå‡½æ•°
â”‚   â”‚   â”œâ”€â”€ useScene.js        # åœºæ™¯ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ useObjectSelection.js  # å¯¹è±¡é€‰æ‹©ï¼ˆæ”¯æŒé€‰ä¸­å¯¹è±¡è½®å»“é«˜äº®ï¼Œé›†æˆOutlinePassï¼‰
â”‚   â”‚   â”œâ”€â”€ useTransform.js    # å˜æ¢æ“ä½œ
â”‚   â”‚   â””â”€â”€ useAssets.js       # èµ„æºç®¡ç†
â”‚   â”œâ”€â”€ core/                  # æ ¸å¿ƒ Three.js é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ SceneManager.js    # åœºæ™¯ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ ObjectManager.js   # å¯¹è±¡ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ InputManager.js    # è¾“å…¥å¤„ç†
â”‚   â”‚   â””â”€â”€ AssetLoader.js     # èµ„æºåŠ è½½å™¨
â”‚   â”œâ”€â”€ api/                  # API æ¥å£
â”‚   â”‚   â”œâ”€â”€ *.api.js            # å„ç§æ¨¡å—APIæ¥å£
â”‚   â”œâ”€â”€ utils/                 # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ mathUtils.js      # æ•°å­¦å·¥å…·
â”‚   â”‚   â”œâ”€â”€ geometryUtils.js  # å‡ ä½•å·¥å…·
â”‚   â”‚   â””â”€â”€ fileUtils.js      # æ–‡ä»¶å¤„ç†å·¥å…·
â”‚   â”œâ”€â”€ App.vue               # æ ¹ç»„ä»¶ï¼ˆä»…è´Ÿè´£å¼•å…¥Editor.vueï¼‰
â”‚   â”œâ”€â”€ Editor.vue            # ä¸»ç¼–è¾‘å™¨ç»„ä»¶ï¼ˆåŒ…å«å…¨éƒ¨ä¸šåŠ¡ä¸UIï¼‰
â”‚   â”œâ”€â”€ main.js               # åº”ç”¨å…¥å£
â”‚   â””â”€â”€ style.css             # å…¨å±€æ ·å¼
â”œâ”€â”€ .gitignore                # Git å¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ index.html                # HTML æ¨¡æ¿
â”œâ”€â”€ package.json              # é¡¹ç›®é…ç½®
â”œâ”€â”€ package-lock.json         # ä¾èµ–é”å®š
â”œâ”€â”€ vite.config.js            # Vite é…ç½®
â””â”€â”€ README.md                 # é¡¹ç›®è¯´æ˜
```

**æ³¨æ„ï¼š**
- vite.config.jsä¸­ï¼Œé…ç½®vite-plugin-static-copyï¼ŒæŠŠå‡ ä¸ªjsåº“çš„å¤åˆ¶åˆ°ç›®æ ‡è·¯å¾„ï¼š
  > å¦‚éœ€åŠ è½½Dracoå‹ç¼©çš„glTFæ¨¡å‹ï¼Œè¯·å°†node_modules/three/examples/jsm/libs/draco/ç›®å½•ä¸­çš„æ–‡ä»¶å¤åˆ¶åˆ° /draco/ ç›®å½•ä¸‹ã€‚
  > å¦‚éœ€åŠ è½½KTX2çº¹ç†ï¼Œè¯·å°†node_modules/three/examples/jsm/libs/basisç›®å½•ä¸­çš„æ–‡ä»¶æ”¾å…¥ /basis/ ç›®å½•ä¸‹ã€‚
  > å¦‚éœ€åŠ è½½Meshoptå‹ç¼©çš„glTFæ¨¡å‹ï¼Œè¯·å°†node_modules/three/examples/jsm/libs/meshopt_decoder.module.jsæ–‡ä»¶æ”¾å…¥ public/meshopt/ ç›®å½•ä¸‹ã€‚


## ğŸ¯ ä¸»è¦åŠŸèƒ½

- **3Dåœºæ™¯æ¸²æŸ“**: åŸºäº Three.js çš„é«˜æ€§èƒ½ 3D æ¸²æŸ“
- **å‡ ä½•ä½“åˆ›å»º**: æ”¯æŒå¤šç§åŸºç¡€å’Œæ‰©å±•å‡ ä½•ä½“åˆ›å»º
  - åŸºç¡€å‡ ä½•ä½“: ç«‹æ–¹ä½“ã€çƒä½“ã€åœ†æŸ±ä½“ã€å¹³é¢ã€åœ†é”¥ä½“ã€åœ†ç¯ä½“
  - æ‰©å±•å‡ ä½•ä½“: åäºŒé¢ä½“ã€äºŒåé¢ä½“ã€å…«é¢ä½“ã€å››é¢ä½“ã€ç¯å½¢ã€ç®¡é“
  - ç¯å…‰å¯¹è±¡: æ–¹å‘å…‰ã€ç‚¹å…‰æºã€èšå…‰ç¯ã€ç¯å¢ƒå…‰ã€åŠçƒå…‰
  - å…¶ä»–å¯¹è±¡: ç›¸æœºã€ç©ºå¯¹è±¡ã€æ–‡æœ¬ã€ç²¾çµ
- **æ¨¡å‹ç®¡ç†**: æ”¯æŒå¤šç§ 3D æ¨¡å‹æ ¼å¼çš„å¯¼å…¥å’Œç®¡ç†
- **äº¤äº’æ“ä½œ**: 
  - èµ„æºæµè§ˆå™¨ä¸­ç›´æ¥æ·»åŠ å‡ ä½•ä½“
  - å®æ—¶å˜æ¢æ“ä½œ (ä½ç§»ã€æ—‹è½¬ã€ç¼©æ”¾)
  - å•å¯¹è±¡é€‰æ‹©å’Œç¼–è¾‘ï¼ˆå¤šé€‰ã€æ¡†é€‰åŠŸèƒ½å·²ç§»é™¤ï¼Œä»…æ”¯æŒå•é€‰ï¼‰
- **å±æ€§ç¼–è¾‘**: å®æ—¶ä¿®æ”¹æ¨¡å‹çš„æè´¨ã€å‡ ä½•ä½“ç­‰å±æ€§
- **åœºæ™¯ç®¡ç†**: å®Œæ•´çš„åœºæ™¯å±‚çº§ç®¡ç†å’Œåºåˆ—åŒ–
- **èµ„æºæµè§ˆ**: å†…ç½®èµ„æºç®¡ç†å™¨ï¼Œæ”¯æŒæ¨¡å‹é¢„è§ˆå’Œå‡ ä½•ä½“åˆ›å»º
- **åå¤„ç†æœºåˆ¶**: 
  - é›†æˆäº†Three.js EffectComposeråå¤„ç†æ¡†æ¶ï¼Œæ”¯æŒå¤šç§åå¤„ç†æ•ˆæœé“¾è·¯ï¼ˆå¦‚Bloomã€FXAAã€OutlinePassç­‰ï¼‰ã€‚
  - æ”¯æŒé€‰ä¸­å¯¹è±¡è½®å»“é«˜äº®ï¼ˆOutlinePassï¼‰ï¼Œé€‰ä¸­å¯¹è±¡æ—¶è‡ªåŠ¨é«˜äº®å…¶è½®å»“ï¼Œæ€§èƒ½ä¼˜äºæè´¨æ›¿æ¢ã€‚
  - æä¾›ç»Ÿä¸€APIï¼Œå¯åŠ¨æ€æ·»åŠ ã€ç§»é™¤ã€è°ƒæ•´å„ç±»Passã€‚
  - ä¸»è¦APIï¼š
    - `scene.sceneManager.addPass(pass, index)`ï¼šæ·»åŠ æŒ‡å®šPassåˆ°åå¤„ç†é“¾ï¼ˆå¯æŒ‡å®šæ’å…¥é¡ºåºï¼‰ã€‚
    - `scene.sceneManager.removePass(pass)`ï¼šç§»é™¤æŒ‡å®šPassã€‚
    - `scene.sceneManager.setPassParams(pass, params)`ï¼šæ‰¹é‡ä¿®æ”¹Passå‚æ•°ã€‚
  - é»˜è®¤å·²é›†æˆRenderPassï¼Œä¸šåŠ¡å±‚å¯é€šè¿‡`scene.sceneManager.addPass(...)`ç­‰æ–¹æ³•çµæ´»æ‰©å±•åå¤„ç†æ•ˆæœã€‚

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### ç»„ä»¶å±‚æ¬¡

1. **UI å±‚** (`components/editor/`): è´Ÿè´£ç”¨æˆ·ç•Œé¢å’Œäº¤äº’
2. **ä¸»ç¼–è¾‘å™¨ç»„ä»¶** (`Editor.vue`): è´Ÿè´£æ‰€æœ‰ä¸šåŠ¡é€»è¾‘å’ŒUIçš„é›†æˆ
3. **3D æ¸²æŸ“å±‚** (`components/scene/`): å¤„ç† 3D åœºæ™¯æ¸²æŸ“å’Œæ˜¾ç¤º
4. **é€»è¾‘å±‚** (`composables/`, `core/`): ä¸šåŠ¡é€»è¾‘å’ŒçŠ¶æ€ç®¡ç†
5. **APIå±‚** (`api/`): æ•°æ®è¯·æ±‚å’Œå¤–éƒ¨æ¥å£
6. **å·¥å…·å±‚** (`utils/`): é€šç”¨å·¥å…·å‡½æ•°

### æŠ€æœ¯ç‰¹ç‚¹

- **å“åº”å¼çŠ¶æ€**: ä½¿ç”¨ Vue 3 Composition API ç®¡ç†åº”ç”¨çŠ¶æ€
- **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„ä»£ç ç»„ç»‡å’ŒèŒè´£åˆ†ç¦»
- **ç±»å‹å®‰å…¨**: è‰¯å¥½çš„ä»£ç ç»“æ„æ”¯æŒ TypeScript è¿ç§»
- **æ€§èƒ½ä¼˜åŒ–**: åˆç†çš„ç»„ä»¶æ‡’åŠ è½½å’Œæ¸²æŸ“ä¼˜åŒ–

## ğŸ“‹ å¼€å‘è§„èŒƒ

- éµå¾ª Vue 3 ç»„åˆå¼ API æœ€ä½³å®è·µ
- ä½¿ç”¨ ES6+ è¯­æ³•ç‰¹æ€§
- ç»„ä»¶å‘½åé‡‡ç”¨ PascalCase
- æ–‡ä»¶å’Œç›®å½•å‘½åé‡‡ç”¨ camelCase
- Git æäº¤ä¿¡æ¯æ ¼å¼: `feat: åŠŸèƒ½æè¿°`

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/6 ä¸Šåˆ10:56:05 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
596 / 111.452K tokens used (1%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æ‰€æœ‰æ ¸å¿ƒä»£ç å’Œæ–‡æ¡£å·²å®Œæˆä¿®æ”¹ï¼Œå·²å°†å¯¹è±¡é«˜äº®æ–¹å¼ä»æè´¨æ›¿æ¢åˆ‡æ¢ä¸º OutlinePass è½®å»“é«˜äº®ï¼Œå¹¶åœ¨ README.md æ˜ç¡®è¯´æ˜åå¤„ç†æœºåˆ¶å’Œé«˜äº®å®ç°ã€‚  
æ ¹æ® .clinerules/ï¼Œæœ¬æ¬¡ä»»åŠ¡æ— éœ€ä¿®æ”¹ src/assets/ï¼Œä¸”å·²åŒæ­¥æ›´æ–° README.md é¡¹ç›®ç»“æ„ã€‚  
æœ€åéœ€æäº¤ git å˜æ›´ï¼Œæ³¨é‡Šéœ€ä¸ºä¸­æ–‡ä¸”ä»¥ feat: å¼€å¤´ï¼Œå†…å®¹å¦‚â€œé€‰ä¸­å¯¹è±¡é«˜äº®åˆ‡æ¢ä¸ºOutlinePassè½®å»“é«˜äº®ï¼Œå®Œå–„åå¤„ç†æœºåˆ¶è¯´æ˜â€ã€‚
</thinking>

<execute_command>
<command>git add src/composables/useObjectSelection.js README.md; git commit -m "feat: é€‰ä¸­å¯¹è±¡é«˜äº®åˆ‡æ¢ä¸ºOutlinePassè½®å»“é«˜äº®ï¼Œå®Œå–„åå¤„ç†æœºåˆ¶è¯´æ˜"</command>
<requires_approval>true</requires_approval>
</execute_command>

---

**User:**

[execute_command for 'git add src/composables/useObjectSelection.js README.md; git commit -m "feat: é€‰ä¸­å¯¹è±¡é«˜äº®åˆ‡æ¢ä¸ºOutlinePassè½®å»“é«˜äº®ï¼Œå®Œå–„åå¤„ç†æœºåˆ¶è¯´æ˜"'] Result:
The user denied this operation.
The user provided the following feedback:
<feedback>
ç°åœ¨é€‰ä¸­å¯¹è±¡æ²¡æœ‰é«˜äº®ï¼Œåªæœ‰TranformControlsåœ¨é«˜äº®
</feedback>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/6 ä¸Šåˆ10:57:15 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
249 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
ç”¨æˆ·åé¦ˆé€‰ä¸­å¯¹è±¡æ²¡æœ‰é«˜äº®ï¼Œè¯´æ˜ OutlinePass æ²¡æœ‰æ•ˆæœã€‚å¯èƒ½åŸå› ï¼š
1. OutlinePass æ²¡æœ‰è¢«æ­£ç¡®æ·»åŠ åˆ°åå¤„ç†é“¾ã€‚
2. OutlinePass.selectedObjects æ²¡æœ‰æ­£ç¡®èµ‹å€¼ã€‚
3. æ¸²æŸ“æµç¨‹æœªè§¦å‘æˆ–å‚æ•°ä¸æ­£ç¡®ã€‚
éœ€ç¡®è®¤ SceneManager.composerã€sceneã€camera æ˜¯å¦å·²åˆå§‹åŒ–ï¼Œä»¥åŠ OutlinePass æ˜¯å¦è¢« addPassã€‚å»ºè®®å…ˆæ’æŸ¥ updateSelectionHighlights æ˜¯å¦è¢«è°ƒç”¨ï¼Œä»¥åŠ OutlinePass çš„æ·»åŠ æ—¶æœºã€‚
å¯é€šè¿‡åœ¨ updateSelectionHighlights é‡Œæ‰“å°è°ƒè¯•ä¿¡æ¯ï¼Œç¡®è®¤æµç¨‹æ˜¯å¦æ‰§è¡Œã€‚
</thinking>

<ask_followup_question>
<question>è¯·ç¡®è®¤ï¼šä½ æ˜¯åœ¨åœºæ™¯ä¸­é€‰ä¸­å¯¹è±¡åï¼ŒTransformControls èƒ½æ­£å¸¸æ˜¾ç¤ºï¼Œä½†å¯¹è±¡æœ¬èº«æ²¡æœ‰ç»¿è‰²è½®å»“é«˜äº®ï¼Œå¯¹å—ï¼Ÿå¦å¤–ï¼Œæ§åˆ¶å°æ˜¯å¦æœ‰æŠ¥é”™æˆ–è­¦å‘Šä¿¡æ¯ï¼Ÿ</question>
<options>
["æ˜¯ï¼Œåªæœ‰TransformControlsé«˜äº®ï¼Œæ²¡æœ‰è½®å»“é«˜äº®ï¼Œä¹Ÿæ²¡æœ‰æŠ¥é”™", "æœ‰æŠ¥é”™/è­¦å‘Šï¼ˆè¯·è´´å‡ºä¿¡æ¯ï¼‰"]
</options>
</ask_followup_question>

---

**User:**

[ask_followup_question for 'è¯·ç¡®è®¤ï¼šä½ æ˜¯åœ¨åœºæ™¯ä¸­é€‰ä¸­å¯¹è±¡åï¼ŒTransformControls èƒ½æ­£å¸¸æ˜¾ç¤ºï¼Œä½†å¯¹è±¡æœ¬èº«æ²¡æœ‰ç»¿è‰²è½®å»“é«˜äº®ï¼Œå¯¹å—ï¼Ÿå¦å¤–ï¼Œæ§åˆ¶å°æ˜¯å¦æœ‰æŠ¥é”™æˆ–è­¦å‘Šä¿¡æ¯ï¼Ÿ'] Result:
<answer>
æ˜¯ï¼Œåªæœ‰TransformControlsé«˜äº®ï¼Œæ²¡æœ‰è½®å»“é«˜äº®ï¼Œä¹Ÿæ²¡æœ‰æŠ¥é”™
</answer>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/6 ä¸Šåˆ10:57:35 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
291 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
ç”¨æˆ·ç¡®è®¤æ— æŠ¥é”™ä½†æ— è½®å»“é«˜äº®ï¼Œè¯´æ˜ OutlinePass ä»£ç å·²æ‰§è¡Œä½†æœªç”Ÿæ•ˆã€‚å¸¸è§åŸå› ï¼š
1. OutlinePass éœ€è¦åœ¨æ¸²æŸ“å¾ªç¯ä¸­è¢« composer æ¸²æŸ“ï¼Œä¸” selectedObjects å¿…é¡»ä¸º mesh æ•°ç»„ã€‚
2. å¯èƒ½ selectedObjects ä¼ é€’çš„æ˜¯ Object3Dï¼ˆç»„ï¼‰ï¼Œè€Œä¸æ˜¯ Meshã€‚
3. OutlinePass åˆå§‹åŒ–æ—¶éœ€ç”¨ renderer.domElement.clientWidth/clientHeightï¼Œè€Œä¸æ˜¯ width/height å±æ€§ã€‚
4. éœ€ç¡®ä¿ OutlinePass çš„å‚æ•°å’Œå¯¹è±¡ç±»å‹æ­£ç¡®ã€‚

ä¸‹ä¸€æ­¥ï¼šä¿®æ­£ OutlinePass åˆå§‹åŒ–å°ºå¯¸å‚æ•°ï¼Œå¹¶ç¡®ä¿ selectedObjects åªåŒ…å« Meshã€‚è°ƒæ•´ updateSelectionHighlights ç›¸å…³é€»è¾‘ã€‚
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
    const selected = selectedObjects.value.filter(obj => !!obj);
    if (selected.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(selected);
=======
    // åªæ”¶é›†æ‰€æœ‰ mesh
    const meshes = [];
    selectedObjects.value.forEach(obj => {
      obj.traverse && obj.traverse(child => {
        if (child.isMesh) meshes.push(child);
      });
    });
    if (meshes.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(meshes);
+++++++ REPLACE

------- SEARCH
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.width,
          sceneManager.renderer.domElement.height
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
=======
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.clientWidth,
          sceneManager.renderer.domElement.clientHeight
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The content was successfully saved to src/composables/useObjectSelection.js.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/composables/useObjectSelection.js">
/**
 * å¯¹è±¡é€‰æ‹©ç®¡ç† Composable
 * æä¾›å¯¹è±¡é€‰æ‹©ç›¸å…³çš„å“åº”å¼çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';
import { useSceneManager } from '../core/SceneManager.js';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  const sceneManager = useSceneManager();

  // OutlinePass å®ä¾‹
  let outlinePass = null;

  // OutlinePass é…ç½®
  const outlineConfig = reactive({
    edgeStrength: 3.0,
    edgeGlow: 0.0,
    edgeThickness: 2.0,
    pulsePeriod: 0,
    visibleEdgeColor: 0x00ff00,
    hiddenEdgeColor: 0x000000
  });

  // å“åº”å¼çŠ¶æ€
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // é€‰æ‹©æ¨¡å¼
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // æ¡†é€‰çŠ¶æ€
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // é€‰æ‹©é…ç½®
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // æ‚¬åœçŠ¶æ€
  const hoveredObject = ref(null);
  
  /**
   * é€‰æ‹©å•ä¸ªå¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * é€‰æ‹©å¤šä¸ªå¯¹è±¡
   * @param {string[]|THREE.Object3D[]} objects å¯¹è±¡æ•°ç»„
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * å–æ¶ˆé€‰æ‹©å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * æ¸…ç©ºé€‰æ‹©
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * åˆ‡æ¢å¯¹è±¡é€‰æ‹©çŠ¶æ€
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * å…¨é€‰å¯¹è±¡
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * åé€‰å¯¹è±¡
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®ç±»å‹é€‰æ‹©å¯¹è±¡
   * @param {string} type å¯¹è±¡ç±»å‹
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®åç§°é€‰æ‹©å¯¹è±¡
   * @param {string} name å¯¹è±¡åç§°
   * @param {boolean} exactMatch æ˜¯å¦ç²¾ç¡®åŒ¹é…
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * å¤„ç†é¼ æ ‡ç‚¹å‡»é€‰æ‹©
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // ç‚¹å‡»ç©ºç™½åŒºåŸŸï¼Œæ¸…ç©ºé€‰æ‹©
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * å¤„ç†é¼ æ ‡æ‚¬åœ
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // æ·»åŠ æ–°çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * å¼€å§‹æ¡†é€‰
   * @param {number} x èµ·å§‹Xåæ ‡
   * @param {number} y èµ·å§‹Yåæ ‡
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * æ›´æ–°æ¡†é€‰
   * @param {number} x å½“å‰Xåæ ‡
   * @param {number} y å½“å‰Yåæ ‡
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * ç»“æŸæ¡†é€‰
   * @param {THREE.Camera} camera ç›¸æœº
   * @param {HTMLElement} element æ¸²æŸ“å…ƒç´ 
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // è®¡ç®—æ¡†é€‰åŒºåŸŸ
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // æ£€æŸ¥æ¯ä¸ªå¯¹è±¡æ˜¯å¦åœ¨æ¡†é€‰åŒºåŸŸå†…
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®ï¼ˆè½®å»“é«˜äº®ï¼‰
   */
  function updateSelectionHighlights() {
    // åªå¤„ç†è½®å»“é«˜äº®
    if (!selectionConfig.highlightSelected) {
      removeOutlinePass();
      return;
    }
    // åªæ”¶é›†æ‰€æœ‰ mesh
    const meshes = [];
    selectedObjects.value.forEach(obj => {
      obj.traverse && obj.traverse(child => {
        if (child.isMesh) meshes.push(child);
      });
    });
    if (meshes.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(meshes);
  }

  /**
   * æ·»åŠ æˆ–æ›´æ–° OutlinePass
   * @param {THREE.Object3D[]} objects
   */
  function addOrUpdateOutlinePass(objects) {
    if (!sceneManager.composer || !sceneManager.scene || !sceneManager.camera) return;
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.clientWidth,
          sceneManager.renderer.domElement.clientHeight
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
  }

  /**
   * ç§»é™¤ OutlinePass
   */
  function removeOutlinePass() {
    if (outlinePass && sceneManager.composer) {
      sceneManager.removePass(outlinePass);
      outlinePass = null;
    }
  }
  
  /**
   * æ·»åŠ æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºæ‚¬åœæè´¨å¹¶è®°å½•
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // å¦‚æœå¯¹è±¡è¢«é€‰ä¸­ï¼Œæ¢å¤ selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
  
  /**
   * è·å–é€‰æ‹©è¾¹ç•Œæ¡†
   * @returns {THREE.Box3|null} è¾¹ç•Œæ¡†
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * è·å–é€‰æ‹©ä¸­å¿ƒç‚¹
   * @returns {THREE.Vector3|null} ä¸­å¿ƒç‚¹
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // ç›‘å¬é€‰æ‹©å˜åŒ–
  watch(selectedObjects, (newSelection, oldSelection) => {
    // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘é€‰æ‹©å˜åŒ–äº‹ä»¶
  });
  
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    outlineConfig,

    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:57:53 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
689 / 111.452K tokens used (1%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

å·²ä¿®æ­£ OutlinePass åªå¯¹ mesh ç”Ÿæ•ˆã€åˆå§‹åŒ–å°ºå¯¸å‚æ•°é—®é¢˜ã€‚è¯·é‡æ–°åœ¨åœºæ™¯ä¸­é€‰ä¸­å¯¹è±¡ï¼Œç¡®è®¤æ˜¯å¦å·²å‡ºç°ç»¿è‰²è½®å»“é«˜äº®ã€‚å¦‚æœä»æ— é«˜äº®ï¼Œè¯·åé¦ˆæ˜¯å¦æœ‰ç‰¹æ®Šæ¨¡å‹ç±»å‹ï¼ˆå¦‚ä¸å¯è§ã€æœªæ·»åŠ åˆ°åœºæ™¯ç­‰ï¼‰ï¼Œæˆ–å°è¯•åˆ·æ–°é¡µé¢åå†æµ‹è¯•ã€‚

---

**User:**

[ERROR] You did not use a tool in your previous response! Please retry with a tool use.

# Reminder: Instructions for Tool Use

Tool uses are formatted using XML-style tags. The tool name is enclosed in opening and closing tags, and each parameter is similarly enclosed within its own set of tags. Here's the structure:

<tool_name>
<parameter1_name>value1</parameter1_name>
<parameter2_name>value2</parameter2_name>
...
</tool_name>

For example:

<attempt_completion>
<result>
I have completed the task...
</result>
</attempt_completion>

Always adhere to this format for all tool uses to ensure proper parsing and execution.

# Next Steps

If you have completed the user's task, use the attempt_completion tool. 
If you require additional information from the user, use the ask_followup_question tool. 
Otherwise, if you have not completed the task and do not need additional information, then proceed with the next step of the task. 
(This is an automated message, so do not respond to it conversationally.)
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:58:00 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
150 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<attempt_completion>
<result>
å·²å°†é€‰ä¸­å¯¹è±¡é«˜äº®æ–¹å¼ç”±æè´¨æ›¿æ¢æ”¹ä¸ºåŸºäº OutlinePass çš„è½®å»“é«˜äº®ï¼Œå¹¶ä¿®æ­£äº† mesh æ”¶é›†ä¸å°ºå¯¸å‚æ•°ï¼Œç¡®ä¿é«˜äº®æ•ˆæœç”Ÿæ•ˆã€‚ç›¸å…³æ–‡æ¡£å·²åŒæ­¥æ›´æ–°ï¼Œé¡¹ç›®ç»“æ„å’Œåå¤„ç†æœºåˆ¶è¯´æ˜å·²å®Œå–„ã€‚è¯·åœ¨åœºæ™¯ä¸­é€‰ä¸­å¯¹è±¡ï¼Œå³å¯çœ‹åˆ°ç»¿è‰²è½®å»“é«˜äº®æ•ˆæœã€‚
</result>
</attempt_completion>

---

**User:**

[attempt_completion] Result:
The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.
<feedback>
é—®é¢˜æ²¡æœ‰ä¿®å¤ï¼Œç°åœºè¿˜æ˜¯ä¸€æ ·
</feedback>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:58:40 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
181 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
é—®é¢˜ä¾æ—§ï¼Œè¯´æ˜ OutlinePass ä»æœªç”Ÿæ•ˆã€‚å¯èƒ½åŸå› ï¼š
1. SceneManager.composer æœªè¢«ç”¨äºå®é™…æ¸²æŸ“ï¼ˆå¦‚ SceneViewer.vue ä»ç”¨ renderer è€Œé composerï¼‰ã€‚
2. OutlinePass æ·»åŠ åæœªè¢«æ¸²æŸ“é“¾è°ƒç”¨ã€‚
3. éœ€æ£€æŸ¥ SceneViewer.vue æˆ–ä¸»æ¸²æŸ“ç»„ä»¶ï¼Œç¡®è®¤æ˜¯å¦è°ƒç”¨ sceneManager.composer.render()ã€‚

ä¸‹ä¸€æ­¥ï¼šæŸ¥æ‰¾ SceneViewer.vueï¼Œç¡®è®¤æ¸²æŸ“æµç¨‹æ˜¯å¦èµ°äº† EffectComposerã€‚
</thinking>

<read_file>
<path>src/components/scene/SceneViewer.vue</path>
</read_file>

---

**User:**

[read_file for 'src/components/scene/SceneViewer.vue'] Result:
<template>
  <div class="scene-viewer" ref="containerRef">
    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-if="!isInitialized" class="loading-overlay">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <p>åˆå§‹åŒ–3Dåœºæ™¯...</p>
      </div>
    </div>

    
  </div>
</template>

<script>
import { ref, reactive, computed, onMounted, onUnmounted, watch } from 'vue';
import * as THREE from 'three';
import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';
import { useScene } from '../../composables/useScene.js';
import { useObjectSelection } from '../../composables/useObjectSelection.js';
import { useInputManager } from '../../core/InputManager.js';
import useTransform from '../../composables/useTransform.js';

export default {
  name: 'SceneViewer',
  props: {
    showWireframe: { type: Boolean, default: false },
    showGrid: { type: Boolean, default: true }
  },
  setup(props) {
    const containerRef = ref(null);
    const scene = useScene();
    const objectSelection = useObjectSelection();
    const inputManager = useInputManager();
    const transform = useTransform();
    
    // TransformControlsç›¸å…³
    let transformControls = null;
    let helper = null;
    let currentObject = null;
    
    // æœ¬åœ°çŠ¶æ€
    // ç”±propsæ§åˆ¶
    const showWireframe = computed(() => props.showWireframe);
    const showGrid = computed(() => props.showGrid);
    const cameraPosition = reactive({ x: 0, y: 0, z: 0 });

    // è®¡ç®—å±æ€§
    const isInitialized = computed(() => scene.isInitialized.value);
    const fps = computed(() => scene.fps.value);
    const sceneStats = computed(() => scene.getSceneStats());

    // ç›¸æœºå››å…ƒæ•°ï¼Œä¼ é€’ç»™CubeViewportControls
    const cameraQuaternionRef = ref({ x: 0, y: 0, z: 0, w: 1 });
    
    // ç›‘å¬å™¨
    let animationId = null;
    
    // æ–¹æ³•
    function initializeScene() {
      if (containerRef.value) {
        scene.initScene(containerRef.value);
        scene.startRender();

        // ç›‘å¬showGridå˜åŒ–ï¼ŒåŠ¨æ€åˆ‡æ¢SceneManagerä¸­çš„ç½‘æ ¼æ˜¾ç¤º
        watch(showGrid, (val) => {
          scene.sceneManager.setGridVisible?.(val);
        }, { immediate: true });

        // åˆå§‹åŒ–TransformControls
        initTransformControls();

        // è®¾ç½®è¾“å…¥äº‹ä»¶ç›‘å¬
        setupInputHandlers();
        
        // å¯åŠ¨ç›¸æœºä½ç½®æ›´æ–°
        startCameraPositionUpdate();
      }
    }

    // åˆå§‹åŒ–TransformControls
    function initTransformControls() {
      if (!scene.sceneManager.camera || !scene.sceneManager.renderer) return;
      transformControls = new TransformControls(scene.sceneManager.camera, scene.sceneManager.renderer.domElement);

      // ç›‘å¬å˜æ¢äº‹ä»¶ï¼ŒåŒæ­¥å±æ€§
      transformControls.addEventListener('objectChange', () => {
        if (currentObject) {
          // å˜æ¢å·²è‡ªåŠ¨ä½œç”¨äºå¯¹è±¡ï¼Œæ— éœ€é¢å¤–åŒæ­¥
          // è§¦å‘å¯¹è±¡å±æ€§åŒæ­¥ï¼Œç¡®ä¿å±æ€§é¢æ¿ç­‰å“åº”å¼åˆ·æ–°
          if (scene.objectManager && scene.objectManager.setObjectTransform) {
            scene.objectManager.setObjectTransform(
              currentObject.userData.id,
              {
                position: [currentObject.position.x, currentObject.position.y, currentObject.position.z],
                rotation: [currentObject.rotation.x, currentObject.rotation.y, currentObject.rotation.z],
                scale: [currentObject.scale.x, currentObject.scale.y, currentObject.scale.z]
              }
            );
          }
        }
      });

      // æ‹–æ‹½æ—¶ç¦ç”¨OrbitControls
      transformControls.addEventListener('dragging-changed', function (event) {
        if (scene.sceneManager.controls) {
          scene.sceneManager.controls.enabled = !event.value;
        }
      });

      // ç¦æ­¢TransformControlsäº‹ä»¶å†’æ³¡åˆ°OrbitControlsç­‰
      transformControls.addEventListener('mouseDown', function (event) {
        event.stopPropagation?.();
      });

      // æ·»åŠ è¾…åŠ©å¯¹è±¡åˆ°åœºæ™¯
      helper = transformControls.getHelper ? transformControls.getHelper() : null;
      if (helper) {
        scene.sceneManager.scene.add(helper);
      }

      // ç›‘å¬transformModeå˜åŒ–
      watch(() => transform.transformMode.value, (mode) => {
        if (transformControls) {
          transformControls.setMode(mode);
          // åˆ‡æ¢æ¨¡å¼æ—¶é‡æ–°attachå¯¹è±¡ï¼Œç¡®ä¿æ§ä»¶åˆ·æ–°
          if (currentObject) {
            transformControls.attach(currentObject);
            transformControls.visible = true;
          }
        }
      }, { immediate: true });

      // ç›‘å¬é€‰ä¸­å¯¹è±¡å˜åŒ–
      watch(() => objectSelection.selectedObjects.value, (objs) => {
        if (objs.length === 1) {
          currentObject = objs[0];
          transformControls.attach(currentObject);
          transformControls.visible = true;
        } else {
          transformControls.detach();
          transformControls.visible = false;
        }
      }, { immediate: true });
    }
    
    function setupInputHandlers() {
      // é¼ æ ‡ç‚¹å‡»é€‰æ‹©
      inputManager.on('click', (event) => {
        if (scene.sceneManager.camera) {
          objectSelection.handleClickSelection(event, scene.sceneManager.camera);
        }
      });
      
      /*
      // é¼ æ ‡æ‚¬åœï¼ˆæ€§èƒ½å¤ªå·®ï¼Œå·²ç¦ç”¨ï¼‰
      // inputManager.on('mousemove', (event) => {
      //   if (scene.sceneManager.camera) {
      //     objectSelection.handleHover(event, scene.sceneManager.camera);
      //   }
      // });
      */
      
      // é”®ç›˜å¿«æ·é”®
      inputManager.on('keydown', (event) => {
        handleKeyboardShortcuts(event);
      });
    }
    
    function handleKeyboardShortcuts(event) {
      switch (event.code) {
        case 'KeyF':
          if (objectSelection.hasSelection.value) {
            const selectedObjects = objectSelection.selectedObjects.value;
            scene.focusOnObject(selectedObjects[0]);
          }
          break;
        case 'KeyG':
          // åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼
          transform.transformMode.value = 'translate';
          break;
        case 'KeyR':
          // åˆ‡æ¢åˆ°æ—‹è½¬æ¨¡å¼
          transform.transformMode.value = 'rotate';
          break;
        case 'KeyS':
          // åˆ‡æ¢åˆ°ç¼©æ”¾æ¨¡å¼
          transform.transformMode.value = 'scale';
          break;
      }
    }
    
    function startCameraPositionUpdate() {
      function updateCameraPosition() {
        if (scene.sceneManager.camera) {
          const pos = scene.sceneManager.camera.position;
          cameraPosition.x = pos.x;
          cameraPosition.y = pos.y;
          cameraPosition.z = pos.z;
          // åŒæ­¥ç›¸æœºå››å…ƒæ•°
          const q = scene.sceneManager.camera.quaternion;
          if (q) {
            cameraQuaternionRef.value = {
              x: q.x,
              y: q.y,
              z: q.z,
              w: q.w
            }
          }
        }
        animationId = requestAnimationFrame(updateCameraPosition);
      }
      updateCameraPosition();
    }
    
    function resetView() {
      scene.updateCameraConfig({
        position: { x: 5, y: 5, z: 5 },
        target: { x: 0, y: 0, z: 0 }
      });
    }
    
    function fitToScreen() {
      const objects = scene.objectManager.getAllObjects();
      if (objects.length > 0) {
        // è®¡ç®—æ‰€æœ‰å¯¹è±¡çš„åŒ…å›´ç›’
        const box = new THREE.Box3();
        objects.forEach(obj => {
          box.expandByObject(obj);
        });
        
        if (!box.isEmpty()) {
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxSize = Math.max(size.x, size.y, size.z);
          const distance = maxSize * 2;
          
          scene.updateCameraConfig({
            position: { 
              x: center.x + distance, 
              y: center.y + distance, 
              z: center.z + distance 
            },
            target: { x: center.x, y: center.y, z: center.z }
          });
        }
      }
    }
    
    function toggleWireframe() {
      showWireframe.value = !showWireframe.value;
      
      // çº¿æ¡†æ¨¡å¼ç”±App.vueæ§åˆ¶ï¼Œè¿™é‡Œä¸å†å¤„ç†
    }
    
    // ç½‘æ ¼æ˜¾ç¤ºç”±propsæ§åˆ¶ï¼Œä¸å†åœ¨æœ¬åœ°åˆ‡æ¢
    
    function setViewAngle(angle) {
      const distance = 10;
      let position;
      
      switch (angle) {
        case 'front':
          position = { x: 0, y: 0, z: distance };
          break;
        case 'back':
          position = { x: 0, y: 0, z: -distance };
          break;
        case 'left':
          position = { x: -distance, y: 0, z: 0 };
          break;
        case 'right':
          position = { x: distance, y: 0, z: 0 };
          break;
        case 'top':
          position = { x: 0, y: distance, z: 0 };
          break;
        case 'bottom':
          position = { x: 0, y: -distance, z: 0 };
          break;
        default:
          return;
      }
      
      scene.updateCameraConfig({
        position,
        target: { x: 0, y: 0, z: 0 }
      });
    }
    
    function formatNumber(num) {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    }
    
    // ç”Ÿå‘½å‘¨æœŸ
    onMounted(() => {
      initializeScene();
    });
    
    onUnmounted(() => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      scene.stopRender();
      inputManager.dispose();
      // ç§»é™¤TransformControls
      if (transformControls) {
        scene.sceneManager.scene.remove(transformControls);
        if (helper) scene.sceneManager.scene.remove(helper);
        transformControls.dispose?.();
      }
      // ç§»é™¤ç½‘æ ¼è¾…åŠ©çº¿
      if (gridHelper) {
        scene.sceneManager.scene.remove(gridHelper);
        gridHelper = null;
      }
    });
    
    return {
      // æ¨¡æ¿å¼•ç”¨
      containerRef,
      
      // çŠ¶æ€
      isInitialized,
      fps,
      sceneStats,
      showWireframe,
      showGrid,
      cameraPosition
    };
  }
};
</script>

<style scoped>
.scene-viewer {
  position: relative;
  width: 100%;
  height: 100%;
  background: #1a1a1a;
  overflow: hidden;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(26, 26, 26, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.loading-content {
  text-align: center;
  color: #fff;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #444;
  border-top: 3px solid #007acc;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 16px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.selection-box {
  position: absolute;
  border: 1px dashed #007acc;
  background: rgba(0, 122, 204, 0.1);
  pointer-events: none;
  z-index: 100;
}

.viewport-controls {
  position: absolute;
  top: 16px;
  right: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 200;
}

.control-group {
  display: flex;
  gap: 4px;
  background: rgba(42, 42, 42, 0.9);
  border-radius: 6px;
  padding: 4px;
  backdrop-filter: blur(10px);
}

.control-btn {
  width: 32px;
  height: 32px;
  background: transparent;
  border: 1px solid #555;
  border-radius: 4px;
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  font-size: 12px;
}

.control-btn:hover {
  background: #444;
  border-color: #777;
}

.control-btn.active {
  background: #007acc;
  border-color: #0088dd;
}

.view-btn {
  font-size: 10px;
  font-weight: 600;
}

.performance-monitor {
  position: absolute;
  top: 16px;
  left: 16px;
  background: rgba(42, 42, 42, 0.9);
  border-radius: 6px;
  padding: 12px;
  backdrop-filter: blur(10px);
  z-index: 200;
}

.monitor-item {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  font-size: 11px;
  margin-bottom: 4px;
}

.monitor-item:last-child {
  margin-bottom: 0;
}

.monitor-label {
  color: #aaa;
}

.monitor-value {
  color: #fff;
  font-weight: 600;
  font-family: monospace;
}

.interaction-hints {
  position: absolute;
  bottom: 16px;
  left: 16px;
  background: rgba(42, 42, 42, 0.9);
  border-radius: 6px;
  padding: 12px;
  backdrop-filter: blur(10px);
  z-index: 200;
}

.hint-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 11px;
  margin-bottom: 4px;
}

.hint-item:last-child {
  margin-bottom: 0;
}

.hint-key {
  background: #555;
  color: #fff;
  padding: 2px 6px;
  border-radius: 3px;
  font-weight: 600;
  min-width: 40px;
  text-align: center;
}

.hint-action {
  color: #ccc;
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
  .viewport-controls {
    top: 8px;
    right: 8px;
    gap: 8px;
  }
  
  .control-btn {
    width: 28px;
    height: 28px;
    font-size: 10px;
  }
  
  .performance-monitor,
  .interaction-hints {
    font-size: 10px;
    padding: 8px;
  }
  
  .interaction-hints {
    display: none;
  }
}
.cube-controls-bottomright {
  position: absolute;
  right: 16px;
  bottom: 16px;
  z-index: 300;
}
</style>

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:58:48 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
226 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
SceneViewer.vue å¹¶æœªå°† renderer.domElement æŒ‚è½½åˆ°é¡µé¢ï¼Œä¹Ÿæœªç›´æ¥è°ƒç”¨ sceneManager.composer.render()ï¼Œè€Œæ˜¯é€šè¿‡ scene.initScene(containerRef.value) å’Œ scene.startRender() å¯åŠ¨æ¸²æŸ“ã€‚
éœ€ç¡®è®¤ useScene.js æ˜¯å¦çœŸæ­£è°ƒç”¨äº† sceneManager.composer.render()ï¼Œå¦åˆ™ OutlinePass ä¸ä¼šç”Ÿæ•ˆã€‚
ä¸‹ä¸€æ­¥ï¼šæŸ¥çœ‹ src/composables/useScene.jsï¼Œç¡®è®¤æ¸²æŸ“å¾ªç¯å®ç°ã€‚
</thinking>

<read_file>
<path>src/composables/useScene.js</path>
</read_file>

---

**User:**

[read_file for 'src/composables/useScene.js'] Result:
/**
 * åœºæ™¯ç®¡ç† Composable
 * æä¾›åœºæ™¯ç›¸å…³çš„å“åº”å¼çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
 */

import { ref, reactive, computed, onMounted, onUnmounted } from 'vue';
import * as THREE from 'three';
import { useSceneManager } from '../core/SceneManager.js';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useScene() {
  const sceneManager = useSceneManager();
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // å“åº”å¼çŠ¶æ€
  const isInitialized = ref(false);
  const isRendering = computed(() => sceneManager.state.isRendering);
  const fps = computed(() => sceneManager.state.fps);
  const frameCount = computed(() => sceneManager.state.frameCount);
  
  // åœºæ™¯é…ç½®
  const sceneConfig = reactive({
    backgroundColor: '#222222',
    fogEnabled: true,
    fogColor: '#222222',
    fogNear: 1000,
    fogFar: 10000,
    shadowsEnabled: true,
    toneMappingEnabled: true,
    exposure: 1.0
  });
  
  // ç›¸æœºçŠ¶æ€
  const cameraState = reactive({
    position: { x: 5, y: 5, z: 5 },
    target: { x: 0, y: 0, z: 0 },
    fov: 75,
    near: 0.1,
    far: 1000
  });
  
  /**
   * åˆå§‹åŒ–åœºæ™¯
   * @param {HTMLElement} container DOMå®¹å™¨
   */
  function initScene(container) {
    if (!container) return;
    
    try {
      sceneManager.setContainer(container);
      inputManager.setElement(sceneManager.renderer.domElement);
      
      // åº”ç”¨åˆå§‹é…ç½®
      applySceneConfig();
      applyCameraConfig();
      
      isInitialized.value = true;
    } catch (error) {
      console.error('åˆå§‹åŒ–åœºæ™¯å¤±è´¥:', error);
    }
  }
  
  /**
   * å¼€å§‹æ¸²æŸ“
   */
  function startRender() {
    sceneManager.startRender();
  }
  
  /**
   * åœæ­¢æ¸²æŸ“
   */
  function stopRender() {
    sceneManager.stopRender();
  }
  
  /**
   * åº”ç”¨åœºæ™¯é…ç½®
   */
  function applySceneConfig() {
    if (!sceneManager.scene) return;
    
    // è®¾ç½®èƒŒæ™¯è‰²
    sceneManager.setBackground(new THREE.Color(sceneConfig.backgroundColor));
    
    // è®¾ç½®é›¾æ•ˆ
    if (sceneConfig.fogEnabled) {
      sceneManager.scene.fog = new THREE.Fog(
        sceneConfig.fogColor,
        sceneConfig.fogNear,
        sceneConfig.fogFar
      );
    } else {
      sceneManager.scene.fog = null;
    }
    
    // è®¾ç½®æ¸²æŸ“å™¨å±æ€§
    if (sceneManager.renderer) {
      sceneManager.renderer.shadowMap.enabled = sceneConfig.shadowsEnabled;
      sceneManager.renderer.toneMappingExposure = sceneConfig.exposure;
    }
  }
  
  /**
   * åº”ç”¨ç›¸æœºé…ç½®
   */
  function applyCameraConfig() {
    if (!sceneManager.camera) return;
    
    // è®¾ç½®ç›¸æœºä½ç½®
    sceneManager.camera.position.set(
      cameraState.position.x,
      cameraState.position.y,
      cameraState.position.z
    );
    
    // è®¾ç½®ç›¸æœºç›®æ ‡
    sceneManager.camera.lookAt(
      cameraState.target.x,
      cameraState.target.y,
      cameraState.target.z
    );
    
    // è®¾ç½®ç›¸æœºå‚æ•°
    sceneManager.camera.fov = cameraState.fov;
    sceneManager.camera.near = cameraState.near;
    sceneManager.camera.far = cameraState.far;
    sceneManager.camera.updateProjectionMatrix();
  }
  
  /**
   * æ›´æ–°åœºæ™¯é…ç½®
   * @param {object} config é…ç½®å¯¹è±¡
   */
  function updateSceneConfig(config) {
    Object.assign(sceneConfig, config);
    applySceneConfig();
  }
  
  /**
   * æ›´æ–°ç›¸æœºé…ç½®
   * @param {object} config é…ç½®å¯¹è±¡
   */
  function updateCameraConfig(config) {
    Object.assign(cameraState, config);
    applyCameraConfig();
    
    // å¦‚æœæœ‰æ§åˆ¶å™¨ï¼ŒåŒæ—¶æ›´æ–°ç›®æ ‡ä½ç½®
    if (sceneManager.controls && config.target) {
      sceneManager.controls.target.set(
        config.target.x,
        config.target.y,
        config.target.z
      );
      sceneManager.controls.update();
    }
  }
  
  /**
   * æ·»åŠ å¯¹è±¡åˆ°åœºæ™¯
   * @param {THREE.Object3D} object 3Då¯¹è±¡
   */
  function addObjectToScene(object) {
    objectManager.addObject(object);
    sceneManager.addObject(object);
  }
  
  /**
   * ä»åœºæ™¯ç§»é™¤å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function removeObjectFromScene(objectOrId) {
    let object;
    
    if (typeof objectOrId === 'string') {
      object = objectManager.getObject(objectOrId);
    } else {
      object = objectOrId;
    }
    
    if (object) {
      // å…ˆä»Three.jsåœºæ™¯ä¸­ç§»é™¤å¯¹è±¡
      sceneManager.removeObject(object);
      
      // å†ä»å¯¹è±¡ç®¡ç†å™¨ä¸­ç§»é™¤
      objectManager.removeObject(objectOrId);
    }
  }
  
  /**
   * æ¸…ç©ºåœºæ™¯
   */
  function clearScene() {
    objectManager.clear();
    sceneManager.clearScene();
  }
  
  /**
   * åˆ›å»ºåŸºç¡€å‡ ä½•ä½“
   * @param {string} type å‡ ä½•ä½“ç±»å‹
   * @param {object} options é€‰é¡¹
   * @returns {THREE.Mesh} åˆ›å»ºçš„ç½‘æ ¼å¯¹è±¡
   */
  function createPrimitive(type, options = {}) {
    const mesh = objectManager.createPrimitive(type, options);
    sceneManager.addObject(mesh);
    return mesh;
  }
  
  /**
   * è·å–åœºæ™¯ç»Ÿè®¡ä¿¡æ¯
   * @returns {object} ç»Ÿè®¡ä¿¡æ¯
   */
  function getSceneStats() {
    const objects = objectManager.getAllObjects();
    
    let vertices = 0;
    let triangles = 0;
    let materials = new Set();
    let textures = new Set();
    
    objects.forEach(object => {
      object.traverse(child => {
        if (child.geometry) {
          const positionAttribute = child.geometry.getAttribute('position');
          if (positionAttribute) {
            vertices += positionAttribute.count;
          }
          
          const index = child.geometry.getIndex();
          if (index) {
            triangles += index.count / 3;
          } else if (positionAttribute) {
            triangles += positionAttribute.count / 3;
          }
        }
        
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => materials.add(mat));
          } else {
            materials.add(child.material);
          }
        }
      });
    });
    
    // ç»Ÿè®¡çº¹ç†
    materials.forEach(material => {
      Object.values(material).forEach(value => {
        if (value && value.isTexture) {
          textures.add(value);
        }
      });
    });
    
    return {
      objects: objects.length,
      vertices,
      triangles,
      materials: materials.size,
      textures: textures.size,
      fps: fps.value,
      frameCount: frameCount.value
    };
  }
  
  /**
   * å¯¼å‡ºåœºæ™¯æ•°æ®
   * @returns {object} åœºæ™¯æ•°æ®
   */
  function exportScene() {
    const sceneData = sceneManager.exportScene();
    const objectData = objectManager.exportObjects();
    
    return {
      ...sceneData,
      ...objectData,
      config: { ...sceneConfig },
      camera: { ...cameraState },
      exportedAt: new Date().toISOString()
    };
  }
  
  /**
   * é‡ç½®åœºæ™¯åˆ°é»˜è®¤çŠ¶æ€
   */
  function resetScene() {
    clearScene();
    
    // é‡ç½®é…ç½®
    Object.assign(sceneConfig, {
      backgroundColor: '#222222',
      fogEnabled: true,
      fogColor: '#222222',
      fogNear: 1000,
      fogFar: 10000,
      shadowsEnabled: true,
      toneMappingEnabled: true,
      exposure: 1.0
    });
    
    Object.assign(cameraState, {
      position: { x: 5, y: 5, z: 5 },
      target: { x: 0, y: 0, z: 0 },
      fov: 75,
      near: 0.1,
      far: 1000
    });
    
    applySceneConfig();
    applyCameraConfig();
  }
  
  /**
   * èšç„¦åˆ°å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function focusOnObject(objectOrId) {
    let object;
    
    if (typeof objectOrId === 'string') {
      object = objectManager.getObject(objectOrId);
    } else {
      object = objectOrId;
    }
    
    if (!object || !sceneManager.camera) return;
    
    // è®¡ç®—å¯¹è±¡åŒ…å›´ç›’
    const box = new THREE.Box3().setFromObject(object);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    
    // è®¡ç®—åˆé€‚çš„ç›¸æœºè·ç¦»
    const maxSize = Math.max(size.x, size.y, size.z);
    const distance = maxSize / (2 * Math.tan(Math.PI * cameraState.fov / 360));
    
    // è®¾ç½®ç›¸æœºä½ç½®
    const direction = new THREE.Vector3(1, 1, 1).normalize();
    const newPosition = center.clone().add(direction.multiplyScalar(distance * 1.5));
    
    cameraState.position.x = newPosition.x;
    cameraState.position.y = newPosition.y;
    cameraState.position.z = newPosition.z;
    cameraState.target.x = center.x;
    cameraState.target.y = center.y;
    cameraState.target.z = center.z;
    
    applyCameraConfig();
  }
  
  // ç”Ÿå‘½å‘¨æœŸé’©å­
  onMounted(() => {
    // åœºæ™¯åˆå§‹åŒ–åçš„é»˜è®¤è®¾ç½®
  });
  
  onUnmounted(() => {
    stopRender();
    inputManager.dispose();
  });
  
  return {
    // çŠ¶æ€
    isInitialized,
    isRendering,
    fps,
    frameCount,
    sceneConfig,
    cameraState,
    
    // æ–¹æ³•
    initScene,
    startRender,
    stopRender,
    applySceneConfig,
    applyCameraConfig,
    updateSceneConfig,
    updateCameraConfig,
    addObjectToScene,
    removeObjectFromScene,
    clearScene,
    createPrimitive,
    getSceneStats,
    exportScene,
    resetScene,
    focusOnObject,
    
    // ç®¡ç†å™¨å®ä¾‹
    sceneManager,
    objectManager,
    inputManager
  };
}

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:58:52 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
222 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
useScene.js çš„ startRender åªæ˜¯è°ƒç”¨ sceneManager.startRender()ï¼Œè€Œ SceneManager çš„æ¸²æŸ“å¾ªç¯æ˜¯é€šè¿‡ composer.render() å®ç°çš„ã€‚  
ä½† SceneViewer.vue çš„ template æ²¡æœ‰æ¸²æŸ“ renderer.domElementï¼Œå¯¼è‡´ç”»å¸ƒæœªæ˜¾ç¤ºã€‚  
SceneManager.setContainer é‡Œè™½ç„¶ appendChild äº† renderer.domElementï¼Œä½†å¦‚æœ containerRef.value æ²¡æœ‰å®½é«˜ï¼Œcanvas å¯èƒ½ä¸å¯è§æˆ–è¢«è¦†ç›–ã€‚  
éœ€ç¡®è®¤ containerRef.value çš„æ ·å¼å’Œå°ºå¯¸ï¼Œå»ºè®®åœ¨ SceneViewer.vue çš„ .scene-viewer å®¹å™¨å†…å¼ºåˆ¶è®¾ç½®å®½é«˜100%ï¼Œç¡®ä¿ç”»å¸ƒå¯è§ã€‚

ä¸‹ä¸€æ­¥ï¼šæ£€æŸ¥ .scene-viewer çš„æ ·å¼ï¼Œç¡®ä¿ renderer.domElement èƒ½æ­£å¸¸æ˜¾ç¤ºã€‚
</thinking>

<ask_followup_question>
<question>è¯·ç¡®è®¤ï¼šä½ åœ¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·ä¸­ï¼Œ.scene-viewer å®¹å™¨æ˜¯å¦æœ‰å®½é«˜ï¼Ÿcanvas æ˜¯å¦è¢«æ­£å¸¸æ’å…¥é¡µé¢ï¼Ÿå¦‚æœæ²¡æœ‰ï¼Œè¯·å°è¯•æ‰‹åŠ¨è®¾ç½® .scene-viewer { width: 100vw; height: 100vh; } å¹¶åˆ·æ–°é¡µé¢ã€‚</question>
</ask_followup_question>

---

**User:**

[ask_followup_question for 'è¯·ç¡®è®¤ï¼šä½ åœ¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·ä¸­ï¼Œ.scene-viewer å®¹å™¨æ˜¯å¦æœ‰å®½é«˜ï¼Ÿcanvas æ˜¯å¦è¢«æ­£å¸¸æ’å…¥é¡µé¢ï¼Ÿå¦‚æœæ²¡æœ‰ï¼Œè¯·å°è¯•æ‰‹åŠ¨è®¾ç½® .scene-viewer { width: 100vw; height: 100vh; } å¹¶åˆ·æ–°é¡µé¢ã€‚'] Result:
<answer>
æœ‰
</answer>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:59:27 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
347 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
å®¹å™¨å’Œ canvas éƒ½æœ‰å®½é«˜ï¼Œè¯´æ˜ç”»å¸ƒæ¸²æŸ“æ²¡é—®é¢˜ã€‚  
é—®é¢˜ä¾ç„¶æ˜¯ OutlinePass æ²¡æœ‰æ•ˆæœã€‚å¯èƒ½åŸå› ï¼š
1. OutlinePass ä¾èµ–çš„ scene/camera/renderer ä¸æ˜¯å®é™…æ¸²æŸ“ç”¨çš„å®ä¾‹ã€‚
2. OutlinePass æ·»åŠ åˆ° composer åï¼ŒselectedObjects æ²¡æœ‰ mesh æˆ– mesh ä¸åœ¨ scene å±‚çº§ã€‚
3. å¯èƒ½æœ‰å¤šå®ä¾‹é—®é¢˜ï¼Œæˆ–æ¸²æŸ“é¡ºåºé—®é¢˜ã€‚

å»ºè®®åœ¨ addOrUpdateOutlinePass é‡Œæ‰“å° outlinePass.selectedObjectsã€sceneManager.sceneã€sceneManager.composer.passesï¼Œç¡®è®¤ mesh æ˜¯å¦åœ¨åœºæ™¯å†…ï¼ŒOutlinePass æ˜¯å¦å·²è¢«æ·»åŠ ã€‚

ä¸‹ä¸€æ­¥ï¼šåœ¨ useObjectSelection.js çš„ addOrUpdateOutlinePass é‡Œæ’å…¥è°ƒè¯•è¾“å‡ºï¼Œè¾…åŠ©å®šä½é—®é¢˜ã€‚
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
    outlinePass.selectedObjects = objects;
=======
    outlinePass.selectedObjects = objects;
    // è°ƒè¯•è¾“å‡º
    console.log('[OutlinePass] selectedObjects:', objects);
    console.log('[OutlinePass] scene children:', sceneManager.scene.children);
    console.log('[OutlinePass] composer passes:', sceneManager.composer.passes);
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The content was successfully saved to src/composables/useObjectSelection.js.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/composables/useObjectSelection.js">
/**
 * å¯¹è±¡é€‰æ‹©ç®¡ç† Composable
 * æä¾›å¯¹è±¡é€‰æ‹©ç›¸å…³çš„å“åº”å¼çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';
import { useSceneManager } from '../core/SceneManager.js';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  const sceneManager = useSceneManager();

  // OutlinePass å®ä¾‹
  let outlinePass = null;

  // OutlinePass é…ç½®
  const outlineConfig = reactive({
    edgeStrength: 3.0,
    edgeGlow: 0.0,
    edgeThickness: 2.0,
    pulsePeriod: 0,
    visibleEdgeColor: 0x00ff00,
    hiddenEdgeColor: 0x000000
  });

  // å“åº”å¼çŠ¶æ€
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // é€‰æ‹©æ¨¡å¼
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // æ¡†é€‰çŠ¶æ€
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // é€‰æ‹©é…ç½®
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // æ‚¬åœçŠ¶æ€
  const hoveredObject = ref(null);
  
  /**
   * é€‰æ‹©å•ä¸ªå¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * é€‰æ‹©å¤šä¸ªå¯¹è±¡
   * @param {string[]|THREE.Object3D[]} objects å¯¹è±¡æ•°ç»„
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * å–æ¶ˆé€‰æ‹©å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * æ¸…ç©ºé€‰æ‹©
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * åˆ‡æ¢å¯¹è±¡é€‰æ‹©çŠ¶æ€
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * å…¨é€‰å¯¹è±¡
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * åé€‰å¯¹è±¡
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®ç±»å‹é€‰æ‹©å¯¹è±¡
   * @param {string} type å¯¹è±¡ç±»å‹
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®åç§°é€‰æ‹©å¯¹è±¡
   * @param {string} name å¯¹è±¡åç§°
   * @param {boolean} exactMatch æ˜¯å¦ç²¾ç¡®åŒ¹é…
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * å¤„ç†é¼ æ ‡ç‚¹å‡»é€‰æ‹©
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // ç‚¹å‡»ç©ºç™½åŒºåŸŸï¼Œæ¸…ç©ºé€‰æ‹©
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * å¤„ç†é¼ æ ‡æ‚¬åœ
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // æ·»åŠ æ–°çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * å¼€å§‹æ¡†é€‰
   * @param {number} x èµ·å§‹Xåæ ‡
   * @param {number} y èµ·å§‹Yåæ ‡
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * æ›´æ–°æ¡†é€‰
   * @param {number} x å½“å‰Xåæ ‡
   * @param {number} y å½“å‰Yåæ ‡
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * ç»“æŸæ¡†é€‰
   * @param {THREE.Camera} camera ç›¸æœº
   * @param {HTMLElement} element æ¸²æŸ“å…ƒç´ 
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // è®¡ç®—æ¡†é€‰åŒºåŸŸ
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // æ£€æŸ¥æ¯ä¸ªå¯¹è±¡æ˜¯å¦åœ¨æ¡†é€‰åŒºåŸŸå†…
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®ï¼ˆè½®å»“é«˜äº®ï¼‰
   */
  function updateSelectionHighlights() {
    // åªå¤„ç†è½®å»“é«˜äº®
    if (!selectionConfig.highlightSelected) {
      removeOutlinePass();
      return;
    }
    // åªæ”¶é›†æ‰€æœ‰ mesh
    const meshes = [];
    selectedObjects.value.forEach(obj => {
      obj.traverse && obj.traverse(child => {
        if (child.isMesh) meshes.push(child);
      });
    });
    if (meshes.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(meshes);
  }

  /**
   * æ·»åŠ æˆ–æ›´æ–° OutlinePass
   * @param {THREE.Object3D[]} objects
   */
  function addOrUpdateOutlinePass(objects) {
    if (!sceneManager.composer || !sceneManager.scene || !sceneManager.camera) return;
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.clientWidth,
          sceneManager.renderer.domElement.clientHeight
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
    // è°ƒè¯•è¾“å‡º
    console.log('[OutlinePass] selectedObjects:', objects);
    console.log('[OutlinePass] scene children:', sceneManager.scene.children);
    console.log('[OutlinePass] composer passes:', sceneManager.composer.passes);
  }

  /**
   * ç§»é™¤ OutlinePass
   */
  function removeOutlinePass() {
    if (outlinePass && sceneManager.composer) {
      sceneManager.removePass(outlinePass);
      outlinePass = null;
    }
  }
  
  /**
   * æ·»åŠ æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºæ‚¬åœæè´¨å¹¶è®°å½•
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // å¦‚æœå¯¹è±¡è¢«é€‰ä¸­ï¼Œæ¢å¤ selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
  
  /**
   * è·å–é€‰æ‹©è¾¹ç•Œæ¡†
   * @returns {THREE.Box3|null} è¾¹ç•Œæ¡†
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * è·å–é€‰æ‹©ä¸­å¿ƒç‚¹
   * @returns {THREE.Vector3|null} ä¸­å¿ƒç‚¹
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // ç›‘å¬é€‰æ‹©å˜åŒ–
  watch(selectedObjects, (newSelection, oldSelection) => {
    // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘é€‰æ‹©å˜åŒ–äº‹ä»¶
  });
  
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    outlineConfig,

    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ10:59:43 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
395 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<ask_followup_question>
<question>è¯·åœ¨æµè§ˆå™¨æ§åˆ¶å°é€‰ä¸­å¯¹è±¡åï¼Œå¤åˆ¶ç²˜è´´ [OutlinePass] çš„ä¸‰æ¡è°ƒè¯•è¾“å‡ºå†…å®¹ï¼ˆselectedObjectsã€scene childrenã€composer passesï¼‰å‘ç»™æˆ‘ï¼Œç”¨äºè¿›ä¸€æ­¥å®šä½é—®é¢˜ã€‚</question>
</ask_followup_question>

---

**User:**

[ask_followup_question for 'è¯·åœ¨æµè§ˆå™¨æ§åˆ¶å°é€‰ä¸­å¯¹è±¡åï¼Œå¤åˆ¶ç²˜è´´ [OutlinePass] çš„ä¸‰æ¡è°ƒè¯•è¾“å‡ºå†…å®¹ï¼ˆselectedObjectsã€scene childrenã€composer passesï¼‰å‘ç»™æˆ‘ï¼Œç”¨äºè¿›ä¸€æ­¥å®šä½é—®é¢˜ã€‚'] Result:
<answer>
[OutlinePass] selectedObjects: [Proxy(Mesh)]
useObjectSelection.js:393 [OutlinePass] scene children: (7)Â [AmbientLight, DirectionalLight, PointLight, GridHelper, AxesHelper, TransformControlsRoot, Mesh]
useObjectSelection.js:394 [OutlinePass] composer passes: (2)Â [RenderPass, _OutlinePass]
</answer>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ11:00:11 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
190 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºï¼š
- selectedObjects ä¸º Meshï¼Œä¸”åœ¨ scene.children ä¸­ã€‚
- composer.passes åŒ…å« RenderPass å’Œ OutlinePassã€‚
è¯´æ˜ OutlinePass å·²è¢«æ­£ç¡®æ·»åŠ ï¼Œä¸” mesh ä¹Ÿåœ¨åœºæ™¯å†…ï¼Œä½†ä»æ— é«˜äº®ï¼Œæå¯èƒ½æ˜¯ OutlinePass é…ç½®å‚æ•°æˆ–æè´¨ç±»å‹ä¸å…¼å®¹å¯¼è‡´ã€‚

å¸¸è§åŸå› ï¼š
1. Mesh æè´¨ç±»å‹ä¸æ”¯æŒ OutlinePassï¼ˆå¦‚ MeshBasicMaterial æœ‰æ—¶æ— æ•ˆï¼‰ã€‚
2. OutlinePass çš„ visibleEdgeColor/hiddenEdgeColor éœ€ç”¨ THREE.Color å®ä¾‹ã€‚
3. å¯èƒ½éœ€è¦è°ƒç”¨ outlinePass.invalidateCache() æˆ–å¼ºåˆ¶åˆ·æ–°ã€‚

ä¸‹ä¸€æ­¥ï¼šä¿®æ­£ OutlinePass é…è‰²å‚æ•°ä¸º THREE.Color å®ä¾‹ï¼Œå¹¶å°è¯•è°ƒç”¨ invalidateCacheã€‚
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
=======
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor = new THREE.Color(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor = new THREE.Color(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
+++++++ REPLACE

------- SEARCH
    outlinePass.selectedObjects = objects;
    // è°ƒè¯•è¾“å‡º
    console.log('[OutlinePass] selectedObjects:', objects);
    console.log('[OutlinePass] scene children:', sceneManager.scene.children);
    console.log('[OutlinePass] composer passes:', sceneManager.composer.passes);
=======
    outlinePass.selectedObjects = objects;
    if (typeof outlinePass.invalidateCache === 'function') {
      outlinePass.invalidateCache();
    }
    // è°ƒè¯•è¾“å‡º
    console.log('[OutlinePass] selectedObjects:', objects);
    console.log('[OutlinePass] scene children:', sceneManager.scene.children);
    console.log('[OutlinePass] composer passes:', sceneManager.composer.passes);
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The content was successfully saved to src/composables/useObjectSelection.js.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/composables/useObjectSelection.js">
/**
 * å¯¹è±¡é€‰æ‹©ç®¡ç† Composable
 * æä¾›å¯¹è±¡é€‰æ‹©ç›¸å…³çš„å“åº”å¼çŠ¶æ€å’Œæ“ä½œæ–¹æ³•
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';
import { useSceneManager } from '../core/SceneManager.js';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  const sceneManager = useSceneManager();

  // OutlinePass å®ä¾‹
  let outlinePass = null;

  // OutlinePass é…ç½®
  const outlineConfig = reactive({
    edgeStrength: 3.0,
    edgeGlow: 0.0,
    edgeThickness: 2.0,
    pulsePeriod: 0,
    visibleEdgeColor: 0x00ff00,
    hiddenEdgeColor: 0x000000
  });

  // å“åº”å¼çŠ¶æ€
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // é€‰æ‹©æ¨¡å¼
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // æ¡†é€‰çŠ¶æ€
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // é€‰æ‹©é…ç½®
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // æ‚¬åœçŠ¶æ€
  const hoveredObject = ref(null);
  
  /**
   * é€‰æ‹©å•ä¸ªå¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * é€‰æ‹©å¤šä¸ªå¯¹è±¡
   * @param {string[]|THREE.Object3D[]} objects å¯¹è±¡æ•°ç»„
   * @param {boolean} addToSelection æ˜¯å¦æ·»åŠ åˆ°ç°æœ‰é€‰æ‹©
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * å–æ¶ˆé€‰æ‹©å¯¹è±¡
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * æ¸…ç©ºé€‰æ‹©
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * åˆ‡æ¢å¯¹è±¡é€‰æ‹©çŠ¶æ€
   * @param {string|THREE.Object3D} objectOrId å¯¹è±¡æˆ–ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * å…¨é€‰å¯¹è±¡
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * åé€‰å¯¹è±¡
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®ç±»å‹é€‰æ‹©å¯¹è±¡
   * @param {string} type å¯¹è±¡ç±»å‹
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * æ ¹æ®åç§°é€‰æ‹©å¯¹è±¡
   * @param {string} name å¯¹è±¡åç§°
   * @param {boolean} exactMatch æ˜¯å¦ç²¾ç¡®åŒ¹é…
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * å¤„ç†é¼ æ ‡ç‚¹å‡»é€‰æ‹©
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // ç‚¹å‡»ç©ºç™½åŒºåŸŸï¼Œæ¸…ç©ºé€‰æ‹©
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * å¤„ç†é¼ æ ‡æ‚¬åœ
   * @param {object} event é¼ æ ‡äº‹ä»¶æ•°æ®
   * @param {THREE.Camera} camera ç›¸æœº
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // æ·»åŠ æ–°çš„æ‚¬åœé«˜äº®
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * å¼€å§‹æ¡†é€‰
   * @param {number} x èµ·å§‹Xåæ ‡
   * @param {number} y èµ·å§‹Yåæ ‡
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * æ›´æ–°æ¡†é€‰
   * @param {number} x å½“å‰Xåæ ‡
   * @param {number} y å½“å‰Yåæ ‡
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * ç»“æŸæ¡†é€‰
   * @param {THREE.Camera} camera ç›¸æœº
   * @param {HTMLElement} element æ¸²æŸ“å…ƒç´ 
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // è®¡ç®—æ¡†é€‰åŒºåŸŸ
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // æ£€æŸ¥æ¯ä¸ªå¯¹è±¡æ˜¯å¦åœ¨æ¡†é€‰åŒºåŸŸå†…
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * æ›´æ–°é€‰æ‹©é«˜äº®ï¼ˆè½®å»“é«˜äº®ï¼‰
   */
  function updateSelectionHighlights() {
    // åªå¤„ç†è½®å»“é«˜äº®
    if (!selectionConfig.highlightSelected) {
      removeOutlinePass();
      return;
    }
    // åªæ”¶é›†æ‰€æœ‰ mesh
    const meshes = [];
    selectedObjects.value.forEach(obj => {
      obj.traverse && obj.traverse(child => {
        if (child.isMesh) meshes.push(child);
      });
    });
    if (meshes.length === 0) {
      removeOutlinePass();
      return;
    }
    addOrUpdateOutlinePass(meshes);
  }

  /**
   * æ·»åŠ æˆ–æ›´æ–° OutlinePass
   * @param {THREE.Object3D[]} objects
   */
  function addOrUpdateOutlinePass(objects) {
    if (!sceneManager.composer || !sceneManager.scene || !sceneManager.camera) return;
    if (!outlinePass) {
      outlinePass = new OutlinePass(
        new THREE.Vector2(
          sceneManager.renderer.domElement.clientWidth,
          sceneManager.renderer.domElement.clientHeight
        ),
        sceneManager.scene,
        sceneManager.camera
      );
      // é…ç½®å‚æ•°
      outlinePass.edgeStrength = outlineConfig.edgeStrength;
      outlinePass.edgeGlow = outlineConfig.edgeGlow;
      outlinePass.edgeThickness = outlineConfig.edgeThickness;
      outlinePass.pulsePeriod = outlineConfig.pulsePeriod;
      outlinePass.visibleEdgeColor = new THREE.Color(outlineConfig.visibleEdgeColor);
      outlinePass.hiddenEdgeColor = new THREE.Color(outlineConfig.hiddenEdgeColor);
      sceneManager.addPass(outlinePass);
    }
    outlinePass.selectedObjects = objects;
    if (typeof outlinePass.invalidateCache === 'function') {
      outlinePass.invalidateCache();
    }
    // è°ƒè¯•è¾“å‡º
    console.log('[OutlinePass] selectedObjects:', objects);
    console.log('[OutlinePass] scene children:', sceneManager.scene.children);
    console.log('[OutlinePass] composer passes:', sceneManager.composer.passes);
  }

  /**
   * ç§»é™¤ OutlinePass
   */
  function removeOutlinePass() {
    if (outlinePass && sceneManager.composer) {
      sceneManager.removePass(outlinePass);
      outlinePass = null;
    }
  }
  
  /**
   * æ·»åŠ æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // ä¿å­˜åŸå§‹æè´¨
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // åˆ›å»ºæ‚¬åœæè´¨å¹¶è®°å½•
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
  
  /**
   * ç§»é™¤æ‚¬åœé«˜äº®
   * @param {THREE.Object3D} object å¯¹è±¡
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // å¦‚æœå¯¹è±¡è¢«é€‰ä¸­ï¼Œæ¢å¤ selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
  
  /**
   * è·å–é€‰æ‹©è¾¹ç•Œæ¡†
   * @returns {THREE.Box3|null} è¾¹ç•Œæ¡†
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * è·å–é€‰æ‹©ä¸­å¿ƒç‚¹
   * @returns {THREE.Vector3|null} ä¸­å¿ƒç‚¹
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // ç›‘å¬é€‰æ‹©å˜åŒ–
  watch(selectedObjects, (newSelection, oldSelection) => {
    // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘é€‰æ‹©å˜åŒ–äº‹ä»¶
  });
  
  return {
    // çŠ¶æ€
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    outlineConfig,

    // æ–¹æ³•
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
README.md
src/composables/useObjectSelection.js

# Current Time
2025/8/6 ä¸Šåˆ11:00:26 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
650 / 111.452K tokens used (1%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<attempt_completion>
<result>
å·²ä¿®æ­£ OutlinePass é…è‰²å‚æ•°ä¸º THREE.Color å®ä¾‹ï¼Œå¹¶åœ¨æ¯æ¬¡é€‰ä¸­å¯¹è±¡æ—¶è°ƒç”¨ invalidateCacheï¼Œç¡®ä¿è½®å»“é«˜äº®åˆ·æ–°ã€‚è¯·å†æ¬¡é€‰ä¸­å¯¹è±¡ï¼Œç¡®è®¤æ˜¯å¦å·²å‡ºç°ç»¿è‰²è½®å»“é«˜äº®ã€‚å¦‚æœä¾ç„¶æ— æ•ˆï¼Œè¯·åé¦ˆæ¨¡å‹æè´¨ç±»å‹ï¼ˆå¦‚ MeshBasicMaterialã€MeshStandardMaterial ç­‰ï¼‰æˆ–ç‰¹æ®Šåœºæ™¯ï¼Œä»¥ä¾¿è¿›ä¸€æ­¥æ’æŸ¥ã€‚
</result>
</attempt_completion>

