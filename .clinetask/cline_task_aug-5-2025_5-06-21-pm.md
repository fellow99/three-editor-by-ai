**User:**

<task>
useObjectSelection.js中，handleHover()函数有些问题：
- 如果对象是被选中的，会有高亮材质
- 但是handleHover在悬停结束时调用removeHoverHighlight()，会把对象选高亮材质给重置为原材质
因此：
- 如果对象是被选中的，应该在userData中记录该高亮材质
- removeHoverHighlight()需要改为先判断对象是否选中，选中则恢复高亮材质，未选中则恢复原材质
- 取消选中时，恢复原材质，userData中移除临时存放的材质对象
</task>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/5 下午5:03:57 (Asia/Shanghai, UTC+8:00)

# Current Working Directory (d:/pci-workspace/3D/three-editor-by-ai) Files
.gitignore
index.html
LICENSE
package-lock.json
package.json
README.md
vite.config.js
public/
public/vite.svg
src/
src/App.vue
src/main.js
src/style.css
src/assets/
src/assets/vue.svg
src/components/
src/components/editor/
src/components/editor/AssetBrowser.vue
src/components/editor/Inspector.vue
src/components/editor/ObjectItem.vue
src/components/editor/PropertyPanel.vue
src/components/editor/Toolbar.vue
src/components/scene/
src/components/scene/Camera.vue
src/components/scene/CubeViewportControls.vue
src/components/scene/InteractionHints.vue
src/components/scene/ObjectGizmo.vue
src/components/scene/PerformanceMonitor.vue
src/components/scene/SceneViewer.vue
src/components/scene/ViewportControls.vue
src/composables/
src/composables/useAssets.js
src/composables/useObjectSelection.js
src/composables/useScene.js
src/composables/useTransform.js
src/core/
src/core/AssetLoader.js
src/core/InputManager.js
src/core/ObjectManager.js
src/core/SceneManager.js
src/services/
src/services/api.js
src/utils/
src/utils/fileUtils.js
src/utils/geometryUtils.js
src/utils/mathUtils.js

# Git Remote URLs
origin: https://github.com/fellow99/three-editor-by-ai.git

# Context Window Usage
0 / 128K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. 用户要求修复 useObjectSelection.js 中 handleHover() 相关的高亮材质逻辑，避免选中对象的高亮材质被悬停逻辑覆盖。
2. 需要查看 useObjectSelection.js，理解 handleHover、removeHoverHighlight 以及选中/取消选中逻辑。
3. 需要修改：选中对象时 userData 记录高亮材质，removeHoverHighlight 判断选中状态决定恢复材质，取消选中时恢复原材质并移除 userData。
4. 先读取 src/composables/useObjectSelection.js 文件内容，分析相关实现。
</thinking>

<read_file>
<path>src/composables/useObjectSelection.js</path>
</read_file>

---

**User:**

[read_file for 'src/composables/useObjectSelection.js'] Result:
/**
 * 对象选择管理 Composable
 * 提供对象选择相关的响应式状态和操作方法
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // 响应式状态
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // 选择模式
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // 框选状态
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // 选择配置
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // 悬停状态
  const hoveredObject = ref(null);
  
  /**
   * 选择单个对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * 选择多个对象
   * @param {string[]|THREE.Object3D[]} objects 对象数组
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * 取消选择对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * 清空选择
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * 切换对象选择状态
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * 全选对象
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * 反选对象
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * 根据类型选择对象
   * @param {string} type 对象类型
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 根据名称选择对象
   * @param {string} name 对象名称
   * @param {boolean} exactMatch 是否精确匹配
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 处理鼠标点击选择
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // 点击空白区域，清空选择
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * 处理鼠标悬停
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // 清除之前的悬停高亮
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // 添加新的悬停高亮
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * 开始框选
   * @param {number} x 起始X坐标
   * @param {number} y 起始Y坐标
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 更新框选
   * @param {number} x 当前X坐标
   * @param {number} y 当前Y坐标
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 结束框选
   * @param {THREE.Camera} camera 相机
   * @param {HTMLElement} element 渲染元素
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // 计算框选区域
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // 检查每个对象是否在框选区域内
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // 将世界坐标转换为屏幕坐标
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * 更新选择高亮
   */
  function updateSelectionHighlights() {
    if (!selectionConfig.highlightSelected) return;
    
    // 移除所有高亮
    objectManager.getAllObjects().forEach(object => {
      removeSelectionHighlight(object);
    });
    
    // 为选中的对象添加高亮
    selectedObjects.value.forEach(object => {
      addSelectionHighlight(object);
    });
  }
  
  /**
   * 添加选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建高亮材质
        const highlightMaterial = child.material.clone();
        highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
        highlightMaterial.emissiveIntensity = 0.3;
        
        child.material = highlightMaterial;
      }
    });
  }
  
  /**
   * 移除选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
  
  /**
   * 添加悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建悬停材质
        const hoverMaterial = child.material.clone();
        hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
        hoverMaterial.emissiveIntensity = 0.2;
        
        child.material = hoverMaterial;
      }
    });
  }
  
  /**
   * 移除悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
  
  /**
   * 获取选择边界框
   * @returns {THREE.Box3|null} 边界框
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * 获取选择中心点
   * @returns {THREE.Vector3|null} 中心点
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // 监听选择变化
  watch(selectedObjects, (newSelection, oldSelection) => {
    // 可以在这里触发选择变化事件
  });
  
  return {
    // 状态
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    
    // 方法
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/5 下午5:04:01 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
170 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
1. 当前 removeHoverHighlight 和 removeSelectionHighlight 都是直接恢复 originalMaterial，未区分选中和悬停高亮，导致选中对象在悬停结束时丢失高亮。
2. 需要：
- 选中高亮时，userData 记录 selectionMaterial；
- 悬停高亮时，userData 记录 hoverMaterial；
- removeHoverHighlight 判断对象是否选中，选中则恢复 selectionMaterial，否则恢复 originalMaterial；
- 取消选中时，恢复 originalMaterial，并移除 selectionMaterial。
3. 需修改 addSelectionHighlight、removeSelectionHighlight、addHoverHighlight、removeHoverHighlight 相关逻辑。
4. 先修改 useObjectSelection.js，完成上述逻辑。
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建高亮材质
        const highlightMaterial = child.material.clone();
        highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
        highlightMaterial.emissiveIntensity = 0.3;
        
        child.material = highlightMaterial;
      }
    });
  }
=======
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建高亮材质并记录
        if (!child.userData.selectionMaterial) {
          const highlightMaterial = child.material.clone();
          highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
          highlightMaterial.emissiveIntensity = 0.3;
          child.userData.selectionMaterial = highlightMaterial;
        }
        child.material = child.userData.selectionMaterial;
      }
    });
  }
+++++++ REPLACE

------- SEARCH
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
=======
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
          delete child.userData.originalMaterial;
        }
        if (child.userData.selectionMaterial) {
          delete child.userData.selectionMaterial;
        }
      }
    });
  }
+++++++ REPLACE

------- SEARCH
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建悬停材质
        const hoverMaterial = child.material.clone();
        hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
        hoverMaterial.emissiveIntensity = 0.2;
        
        child.material = hoverMaterial;
      }
    });
  }
=======
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建悬停材质并记录
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
+++++++ REPLACE

------- SEARCH
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
=======
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // 如果对象被选中，恢复 selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
+++++++ REPLACE

------- SEARCH
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
=======
  function deselectObject(objectOrId)

[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The tool execution failed with the following error:
<error>
The SEARCH block:
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
...does not match anything in the file.

This is likely because the SEARCH block content doesn't match exactly with what's in the file, or if you used multiple SEARCH/REPLACE blocks they may not have been in the order they appear in the file. (Please also ensure that when using the replace_in_file tool, Do NOT add extra characters to the markers (e.g., ------- SEARCH> is INVALID). Do NOT forget to use the closing +++++++ REPLACE marker. Do NOT modify the marker format in any way. Malformed XML will cause complete tool failure and break the entire editing process.)

The file was reverted to its original state:

<file_content path="src/composables/useObjectSelection.js">
/**
 * 对象选择管理 Composable
 * 提供对象选择相关的响应式状态和操作方法
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // 响应式状态
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // 选择模式
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // 框选状态
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // 选择配置
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // 悬停状态
  const hoveredObject = ref(null);
  
  /**
   * 选择单个对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * 选择多个对象
   * @param {string[]|THREE.Object3D[]} objects 对象数组
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * 取消选择对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * 清空选择
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * 切换对象选择状态
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * 全选对象
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * 反选对象
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * 根据类型选择对象
   * @param {string} type 对象类型
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 根据名称选择对象
   * @param {string} name 对象名称
   * @param {boolean} exactMatch 是否精确匹配
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 处理鼠标点击选择
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // 点击空白区域，清空选择
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * 处理鼠标悬停
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // 清除之前的悬停高亮
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // 添加新的悬停高亮
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * 开始框选
   * @param {number} x 起始X坐标
   * @param {number} y 起始Y坐标
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 更新框选
   * @param {number} x 当前X坐标
   * @param {number} y 当前Y坐标
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 结束框选
   * @param {THREE.Camera} camera 相机
   * @param {HTMLElement} element 渲染元素
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // 计算框选区域
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // 检查每个对象是否在框选区域内
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // 将世界坐标转换为屏幕坐标
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * 更新选择高亮
   */
  function updateSelectionHighlights() {
    if (!selectionConfig.highlightSelected) return;
    
    // 移除所有高亮
    objectManager.getAllObjects().forEach(object => {
      removeSelectionHighlight(object);
    });
    
    // 为选中的对象添加高亮
    selectedObjects.value.forEach(object => {
      addSelectionHighlight(object);
    });
  }
  
  /**
   * 添加选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建高亮材质
        const highlightMaterial = child.material.clone();
        highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
        highlightMaterial.emissiveIntensity = 0.3;
        
        child.material = highlightMaterial;
      }
    });
  }
  
  /**
   * 移除选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
  
  /**
   * 添加悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建悬停材质
        const hoverMaterial = child.material.clone();
        hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
        hoverMaterial.emissiveIntensity = 0.2;
        
        child.material = hoverMaterial;
      }
    });
  }
  
  /**
   * 移除悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
  
  /**
   * 获取选择边界框
   * @returns {THREE.Box3|null} 边界框
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * 获取选择中心点
   * @returns {THREE.Vector3|null} 中心点
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // 监听选择变化
  watch(selectedObjects, (newSelection, oldSelection) => {
    // 可以在这里触发选择变化事件
  });
  
  return {
    // 状态
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    
    // 方法
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</file_content>

Now that you have the latest state of the file, try the operation again with fewer, more precise SEARCH blocks. For large files especially, it may be prudent to try to limit yourself to <5 SEARCH/REPLACE blocks at a time, then wait for the user to respond with the result of the operation before following up with another replace_in_file call to make additional edits.
(If you run into this error 3 times in a row, you may use the write_to_file tool as a fallback.)
</error>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/5 下午5:04:24 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
170 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
只修改 addSelectionHighlight、removeSelectionHighlight、addHoverHighlight、removeHoverHighlight 四个函数，分批精确替换，先完成高亮材质的 userData 记录与切换逻辑。每次只做 2 个函数的替换，降低失败概率。
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建高亮材质
        const highlightMaterial = child.material.clone();
        highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
        highlightMaterial.emissiveIntensity = 0.3;
        
        child.material = highlightMaterial;
      }
    });
  }
=======
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建高亮材质并记录
        if (!child.userData.selectionMaterial) {
          const highlightMaterial = child.material.clone();
          highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
          highlightMaterial.emissiveIntensity = 0.3;
          child.userData.selectionMaterial = highlightMaterial;
        }
        child.material = child.userData.selectionMaterial;
      }
    });
  }
+++++++ REPLACE

------- SEARCH
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
=======
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
          delete child.userData.originalMaterial;
        }
        if (child.userData.selectionMaterial) {
          delete child.userData.selectionMaterial;
        }
      }
    });
  }
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The content was successfully saved to src/composables/useObjectSelection.js.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/composables/useObjectSelection.js">
/**
 * 对象选择管理 Composable
 * 提供对象选择相关的响应式状态和操作方法
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // 响应式状态
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // 选择模式
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // 框选状态
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // 选择配置
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // 悬停状态
  const hoveredObject = ref(null);
  
  /**
   * 选择单个对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * 选择多个对象
   * @param {string[]|THREE.Object3D[]} objects 对象数组
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * 取消选择对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * 清空选择
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * 切换对象选择状态
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * 全选对象
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * 反选对象
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * 根据类型选择对象
   * @param {string} type 对象类型
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 根据名称选择对象
   * @param {string} name 对象名称
   * @param {boolean} exactMatch 是否精确匹配
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 处理鼠标点击选择
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // 点击空白区域，清空选择
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * 处理鼠标悬停
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // 清除之前的悬停高亮
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // 添加新的悬停高亮
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * 开始框选
   * @param {number} x 起始X坐标
   * @param {number} y 起始Y坐标
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 更新框选
   * @param {number} x 当前X坐标
   * @param {number} y 当前Y坐标
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 结束框选
   * @param {THREE.Camera} camera 相机
   * @param {HTMLElement} element 渲染元素
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // 计算框选区域
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // 检查每个对象是否在框选区域内
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // 将世界坐标转换为屏幕坐标
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * 更新选择高亮
   */
  function updateSelectionHighlights() {
    if (!selectionConfig.highlightSelected) return;
    
    // 移除所有高亮
    objectManager.getAllObjects().forEach(object => {
      removeSelectionHighlight(object);
    });
    
    // 为选中的对象添加高亮
    selectedObjects.value.forEach(object => {
      addSelectionHighlight(object);
    });
  }
  
  /**
   * 添加选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建高亮材质并记录
        if (!child.userData.selectionMaterial) {
          const highlightMaterial = child.material.clone();
          highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
          highlightMaterial.emissiveIntensity = 0.3;
          child.userData.selectionMaterial = highlightMaterial;
        }
        child.material = child.userData.selectionMaterial;
      }
    });
  }
  
  /**
   * 移除选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
          delete child.userData.originalMaterial;
        }
        if (child.userData.selectionMaterial) {
          delete child.userData.selectionMaterial;
        }
      }
    });
  }
  
  /**
   * 添加悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建悬停材质
        const hoverMaterial = child.material.clone();
        hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
        hoverMaterial.emissiveIntensity = 0.2;
        
        child.material = hoverMaterial;
      }
    });
  }
  
  /**
   * 移除悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
  
  /**
   * 获取选择边界框
   * @returns {THREE.Box3|null} 边界框
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * 获取选择中心点
   * @returns {THREE.Vector3|null} 中心点
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // 监听选择变化
  watch(selectedObjects, (newSelection, oldSelection) => {
    // 可以在这里触发选择变化事件
  });
  
  return {
    // 状态
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    
    // 方法
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/5 下午5:04:39 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
528 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
继续修改 addHoverHighlight 和 removeHoverHighlight，实现 userData.hoverMaterial 记录，并在 removeHoverHighlight 时判断 selectionMaterial 是否存在，优先恢复 selectionMaterial，否则恢复 originalMaterial，并清理 hoverMaterial。
</thinking>

<replace_in_file>
<path>src/composables/useObjectSelection.js</path>
<diff>
------- SEARCH
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // 创建悬停材质
        const hoverMaterial = child.material.clone();
        hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
        hoverMaterial.emissiveIntensity = 0.2;
        
        child.material = hoverMaterial;
      }
    });
  }
=======
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建悬停材质并记录
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
+++++++ REPLACE

------- SEARCH
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.userData.originalMaterial) {
        child.material = child.userData.originalMaterial;
        delete child.userData.originalMaterial;
      }
    });
  }
=======
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // 如果对象被选中，恢复 selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/composables/useObjectSelection.js'] Result:
The content was successfully saved to src/composables/useObjectSelection.js.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/composables/useObjectSelection.js">
/**
 * 对象选择管理 Composable
 * 提供对象选择相关的响应式状态和操作方法
 */

import { ref, reactive, computed, watch } from 'vue';
import * as THREE from 'three';
import { useObjectManager } from '../core/ObjectManager.js';
import { useInputManager } from '../core/InputManager.js';

export function useObjectSelection() {
  const objectManager = useObjectManager();
  const inputManager = useInputManager();
  
  // 响应式状态
  const selectedObjects = computed(() => 
    Array.from(objectManager.state.selectedObjects)
      .map(id => objectManager.getObject(id))
      .filter(Boolean)
  );
  
  const selectedObjectIds = computed(() => 
    Array.from(objectManager.state.selectedObjects)
  );
  
  const hasSelection = computed(() => 
    objectManager.state.selectedObjects.size > 0
  );
  
  const selectionCount = computed(() => 
    objectManager.state.selectedObjects.size
  );
  
  // 选择模式
  const selectionMode = ref('single'); // 'single', 'multiple', 'box'
  
  // 框选状态
  const boxSelection = reactive({
    isActive: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0
  });
  
  // 选择配置
  const selectionConfig = reactive({
    highlightSelected: true,
    highlightColor: 0x00ff00,
    showBoundingBox: true,
    enableHover: true,
    hoverColor: 0xffff00
  });
  
  // 悬停状态
  const hoveredObject = ref(null);
  
  /**
   * 选择单个对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObject(objectOrId, addToSelection = false) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (selectionMode.value === 'single' && !addToSelection) {
      objectManager.selectObjects(id);
    } else {
      objectManager.selectObjects(id, addToSelection);
    }
    
    updateSelectionHighlights();
  }
  
  /**
   * 选择多个对象
   * @param {string[]|THREE.Object3D[]} objects 对象数组
   * @param {boolean} addToSelection 是否添加到现有选择
   */
  function selectObjects(objects, addToSelection = false) {
    const ids = objects.map(obj => 
      typeof obj === 'string' ? obj : obj.userData.id
    ).filter(Boolean);
    
    objectManager.selectObjects(ids, addToSelection);
    updateSelectionHighlights();
  }
  
  /**
   * 取消选择对象
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function deselectObject(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    objectManager.deselectObjects(id);
    updateSelectionHighlights();
  }
  
  /**
   * 清空选择
   */
  function clearSelection() {
    objectManager.clearSelection();
    updateSelectionHighlights();
  }
  
  /**
   * 切换对象选择状态
   * @param {string|THREE.Object3D} objectOrId 对象或ID
   */
  function toggleSelection(objectOrId) {
    let id;
    
    if (typeof objectOrId === 'string') {
      id = objectOrId;
    } else {
      id = objectOrId.userData.id;
    }
    
    if (!id) return;
    
    if (objectManager.state.selectedObjects.has(id)) {
      deselectObject(id);
    } else {
      selectObject(id, selectionMode.value === 'multiple');
    }
  }
  
  /**
   * 全选对象
   */
  function selectAll() {
    const allObjects = objectManager.getAllObjects();
    const allIds = allObjects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(allIds);
    updateSelectionHighlights();
  }
  
  /**
   * 反选对象
   */
  function invertSelection() {
    const allObjects = objectManager.getAllObjects();
    const selectedIds = Array.from(objectManager.state.selectedObjects);
    
    const invertedIds = allObjects
      .map(obj => obj.userData.id)
      .filter(id => id && !selectedIds.includes(id));
    
    objectManager.selectObjects(invertedIds);
    updateSelectionHighlights();
  }
  
  /**
   * 根据类型选择对象
   * @param {string} type 对象类型
   */
  function selectByType(type) {
    const objects = objectManager.getAllObjects()
      .filter(obj => obj.userData.type === type || obj.userData.primitiveType === type);
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 根据名称选择对象
   * @param {string} name 对象名称
   * @param {boolean} exactMatch 是否精确匹配
   */
  function selectByName(name, exactMatch = false) {
    const objects = objectManager.getAllObjects()
      .filter(obj => {
        if (exactMatch) {
          return obj.name === name;
        } else {
          return obj.name.toLowerCase().includes(name.toLowerCase());
        }
      });
    
    const ids = objects.map(obj => obj.userData.id).filter(Boolean);
    objectManager.selectObjects(ids);
    updateSelectionHighlights();
  }
  
  /**
   * 处理鼠标点击选择
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleClickSelection(event, camera) {
    if (!camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    if (intersectedObjects.length > 0) {
      const targetObject = intersectedObjects[0];
      const addToSelection = event.modifiers?.ctrl || event.modifiers?.shift;
      
      if (addToSelection && selectionMode.value === 'multiple') {
        toggleSelection(targetObject);
      } else {
        selectObject(targetObject, false);
      }
    } else {
      // 点击空白区域，清空选择
      if (!event.modifiers?.ctrl && !event.modifiers?.shift) {
        clearSelection();
      }
    }
  }
  
  /**
   * 处理鼠标悬停
   * @param {object} event 鼠标事件数据
   * @param {THREE.Camera} camera 相机
   */
  function handleHover(event, camera) {
    if (!selectionConfig.enableHover || !camera) return;
    
    const raycaster = inputManager.getRaycaster(camera);
    const intersectedObjects = objectManager.getIntersectedObjects(raycaster);
    
    const newHoveredObject = intersectedObjects.length > 0 ? intersectedObjects[0] : null;
    
    if (hoveredObject.value !== newHoveredObject) {
      // 清除之前的悬停高亮
      if (hoveredObject.value) {
        removeHoverHighlight(hoveredObject.value);
      }
      
      hoveredObject.value = newHoveredObject;
      
      // 添加新的悬停高亮
      if (hoveredObject.value) {
        addHoverHighlight(hoveredObject.value);
      }
    }
  }
  
  /**
   * 开始框选
   * @param {number} x 起始X坐标
   * @param {number} y 起始Y坐标
   */
  function startBoxSelection(x, y) {
    if (selectionMode.value !== 'box') return;
    
    boxSelection.isActive = true;
    boxSelection.startX = x;
    boxSelection.startY = y;
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 更新框选
   * @param {number} x 当前X坐标
   * @param {number} y 当前Y坐标
   */
  function updateBoxSelection(x, y) {
    if (!boxSelection.isActive) return;
    
    boxSelection.endX = x;
    boxSelection.endY = y;
  }
  
  /**
   * 结束框选
   * @param {THREE.Camera} camera 相机
   * @param {HTMLElement} element 渲染元素
   */
  function endBoxSelection(camera, element) {
    if (!boxSelection.isActive || !camera || !element) return;
    
    const rect = element.getBoundingClientRect();
    const selectedIds = [];
    
    // 计算框选区域
    const minX = Math.min(boxSelection.startX, boxSelection.endX);
    const maxX = Math.max(boxSelection.startX, boxSelection.endX);
    const minY = Math.min(boxSelection.startY, boxSelection.endY);
    const maxY = Math.max(boxSelection.startY, boxSelection.endY);
    
    // 检查每个对象是否在框选区域内
    objectManager.getAllObjects().forEach(object => {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      
      // 将世界坐标转换为屏幕坐标
      const screenPos = center.clone().project(camera);
      const x = (screenPos.x + 1) / 2 * rect.width;
      const y = -(screenPos.y - 1) / 2 * rect.height;
      
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        selectedIds.push(object.userData.id);
      }
    });
    
    if (selectedIds.length > 0) {
      objectManager.selectObjects(selectedIds);
      updateSelectionHighlights();
    }
    
    boxSelection.isActive = false;
  }
  
  /**
   * 更新选择高亮
   */
  function updateSelectionHighlights() {
    if (!selectionConfig.highlightSelected) return;
    
    // 移除所有高亮
    objectManager.getAllObjects().forEach(object => {
      removeSelectionHighlight(object);
    });
    
    // 为选中的对象添加高亮
    selectedObjects.value.forEach(object => {
      addSelectionHighlight(object);
    });
  }
  
  /**
   * 添加选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function addSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建高亮材质并记录
        if (!child.userData.selectionMaterial) {
          const highlightMaterial = child.material.clone();
          highlightMaterial.emissive = new THREE.Color(selectionConfig.highlightColor);
          highlightMaterial.emissiveIntensity = 0.3;
          child.userData.selectionMaterial = highlightMaterial;
        }
        child.material = child.userData.selectionMaterial;
      }
    });
  }
  
  /**
   * 移除选择高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeSelectionHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
          delete child.userData.originalMaterial;
        }
        if (child.userData.selectionMaterial) {
          delete child.userData.selectionMaterial;
        }
      }
    });
  }
  
  /**
   * 添加悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function addHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh && child.material) {
        // 保存原始材质
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        // 创建悬停材质并记录
        if (!child.userData.hoverMaterial) {
          const hoverMaterial = child.material.clone();
          hoverMaterial.emissive = new THREE.Color(selectionConfig.hoverColor);
          hoverMaterial.emissiveIntensity = 0.2;
          child.userData.hoverMaterial = hoverMaterial;
        }
        child.material = child.userData.hoverMaterial;
      }
    });
  }
  
  /**
   * 移除悬停高亮
   * @param {THREE.Object3D} object 对象
   */
  function removeHoverHighlight(object) {
    object.traverse(child => {
      if (child.isMesh) {
        // 如果对象被选中，恢复 selectionMaterial
        if (child.userData.selectionMaterial) {
          child.material = child.userData.selectionMaterial;
        } else if (child.userData.originalMaterial) {
          child.material = child.userData.originalMaterial;
        }
        if (child.userData.hoverMaterial) {
          delete child.userData.hoverMaterial;
        }
      }
    });
  }
  
  /**
   * 获取选择边界框
   * @returns {THREE.Box3|null} 边界框
   */
  function getSelectionBounds() {
    if (selectedObjects.value.length === 0) return null;
    
    const box = new THREE.Box3();
    
    selectedObjects.value.forEach(object => {
      const objectBox = new THREE.Box3().setFromObject(object);
      box.union(objectBox);
    });
    
    return box;
  }
  
  /**
   * 获取选择中心点
   * @returns {THREE.Vector3|null} 中心点
   */
  function getSelectionCenter() {
    const bounds = getSelectionBounds();
    return bounds ? bounds.getCenter(new THREE.Vector3()) : null;
  }
  
  // 监听选择变化
  watch(selectedObjects, (newSelection, oldSelection) => {
    // 可以在这里触发选择变化事件
  });
  
  return {
    // 状态
    selectedObjects,
    selectedObjectIds,
    hasSelection,
    selectionCount,
    selectionMode,
    boxSelection,
    selectionConfig,
    hoveredObject,
    
    // 方法
    selectObject,
    selectObjects,
    deselectObject,
    clearSelection,
    toggleSelection,
    selectAll,
    invertSelection,
    selectByType,
    selectByName,
    handleClickSelection,
    handleHover,
    startBoxSelection,
    updateBoxSelection,
    endBoxSelection,
    updateSelectionHighlights,
    getSelectionBounds,
    getSelectionCenter
  };
}

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/5 下午5:05:00 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
546 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
还需完善：取消选中时，除了 updateSelectionHighlights，还要确保 userData.selectionMaterial 被移除，材质恢复 originalMaterial。当前 removeSelectionHighlight 已实现此逻辑，无需额外修改。
所有高亮切换逻辑已完成，需同步更新/README.md的项目结构描述，说明 useObjectSelection.js 已修改。
</thinking>

<replace_in_file>
<path>README.md</path>
<diff>
------- SEARCH
src/composables/
=======
src/composables/
  useObjectSelection.js   # 对

[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]

---

**User:**

[replace_in_file for 'README.md'] Result:
The tool execution failed with the following error:
<error>
The SEARCH block:
src/composables/
...does not match anything in the file.

This is likely because the SEARCH block content doesn't match exactly with what's in the file, or if you used multiple SEARCH/REPLACE blocks they may not have been in the order they appear in the file. (Please also ensure that when using the replace_in_file tool, Do NOT add extra characters to the markers (e.g., ------- SEARCH> is INVALID). Do NOT forget to use the closing +++++++ REPLACE marker. Do NOT modify the marker format in any way. Malformed XML will cause complete tool failure and break the entire editing process.)

The file was reverted to its original state:

<file_content path="README.md">
# 3D 场景编辑器 (Three Editor by AI)

一个基于 Vue 3 + Three.js 的现代化3D场景编辑器，支持三维模型的拖放、调整和属性配置。

## ✅ 功能体系
- 3D场景渲染和管理
- 多种基础几何体创建
- 完整的对象变换系统（移动、旋转、缩放）
- 单选（多选、框选功能已移除，仅支持单选）
- 撤销重做历史记录
- 3D模型和纹理加载（GLTF、OBJ、FBX等格式）
- 拖拽上传和资源管理
- 相机控制和预设视角
- 材质编辑和属性调整
- 场景序列化和导入导出

## 🚀 技术栈

- **前端框架**: Vue 3 + Vite
- **3D引擎**: Three.js
- **构建工具**: Vite
- **网络请求**: Fetch API
- **工具库**: 
  - Lodash - 实用工具函数库
  - Day.js - 轻量级日期时间库

## 📁 项目结构

```
three-editor-by-ai/
├── public/                     # 静态资源
│   └── vite.svg
├── src/
│   ├── assets/                 # 静态资源 (3D模型、纹理等)
│   │   └── vue.svg
│   ├── components/             # Vue 组件
│   │   ├── editor/            # 编辑器 UI 组件
│   │   │   ├── PropertyPanel.vue    # 属性面板
│   │   │   ├── Toolbar.vue          # 工具栏
│   │   │   ├── AssetBrowser.vue     # 资源浏览器
│   │   │   └── Inspector.vue        # 对象检查器
│   │   ├── scene/             # 3D 场景组件
│   │   │   ├── SceneViewer.vue      # 主场景视图
│   │   │   ├── PerformanceMonitor.vue   # 性能监控组件
│   │   │   ├── InteractionHints.vue     # 操作提示组件
│   │   │   ├── ViewportControls.vue     # 视图控制面板组件
│   │   │   ├── CubeViewportControls.vue # 立方体视角控件，6面点击切换视角，镜头联动
│   │   │   ├── ObjectGizmo.vue      # 对象操作控制器
│   │   │   └── Camera.vue           # 相机控制
│   ├── composables/           # Vue Composition API 可组合函数
│   │   ├── useScene.js        # 场景管理
│   │   ├── useObjectSelection.js  # 对象选择
│   │   ├── useTransform.js    # 变换操作
│   │   └── useAssets.js       # 资源管理
│   ├── core/                  # 核心 Three.js 逻辑
│   │   ├── SceneManager.js    # 场景管理器
│   │   ├── ObjectManager.js   # 对象管理器
│   │   ├── InputManager.js    # 输入处理
│   │   └── AssetLoader.js     # 资源加载器
│   ├── api/                  # API 接口
│   │   ├── *.api.js            # 各种模块API接口
│   ├── utils/                 # 工具函数
│   │   ├── mathUtils.js      # 数学工具
│   │   ├── geometryUtils.js  # 几何工具
│   │   └── fileUtils.js      # 文件处理工具
│   ├── App.vue               # 根组件
│   ├── main.js               # 应用入口
│   └── style.css             # 全局样式
├── .gitignore                # Git 忽略文件
├── index.html                # HTML 模板
├── package.json              # 项目配置
├── package-lock.json         # 依赖锁定
├── vite.config.js            # Vite 配置
└── README.md                 # 项目说明
```

## 🎯 主要功能

- **3D场景渲染**: 基于 Three.js 的高性能 3D 渲染
- **几何体创建**: 支持多种基础和扩展几何体创建
  - 基础几何体: 立方体、球体、圆柱体、平面、圆锥体、圆环体
  - 扩展几何体: 十二面体、二十面体、八面体、四面体、环形、管道
  - 灯光对象: 方向光、点光源、聚光灯、环境光、半球光
  - 其他对象: 相机、空对象、文本、精灵
- **模型管理**: 支持多种 3D 模型格式的导入和管理
- **交互操作**: 
  - 资源浏览器中直接添加几何体
  - 实时变换操作 (位移、旋转、缩放)
  - 单对象选择和编辑（多选、框选功能已移除，仅支持单选）
- **属性编辑**: 实时修改模型的材质、几何体等属性
- **场景管理**: 完整的场景层级管理和序列化
- **资源浏览**: 内置资源管理器，支持模型预览和几何体创建

## 🏗️ 架构设计

### 组件层次

1. **UI 层** (`components/editor/`): 负责用户界面和交互
2. **3D 渲染层** (`components/scene/`): 处理 3D 场景渲染和显示
3. **逻辑层** (`composables/`, `core/`): 业务逻辑和状态管理
4. **API层** (`api/`): 数据请求和外部接口
5. **工具层** (`utils/`): 通用工具函数

### 技术特点

- **响应式状态**: 使用 Vue 3 Composition API 管理应用状态
- **模块化设计**: 清晰的代码组织和职责分离
- **类型安全**: 良好的代码结构支持 TypeScript 迁移
- **性能优化**: 合理的组件懒加载和渲染优化

## 📋 开发规范

- 遵循 Vue 3 组合式 API 最佳实践
- 使用 ES6+ 语法特性
- 组件命名采用 PascalCase
- 文件和目录命名采用 camelCase
- Git 提交信息格式: `feat: 功能描述`

</file_content>

Now that you have the latest state of the file, try the operation again with fewer, more precise SEARCH blocks. For large files especially, it may be prudent to try to limit yourself to <5 SEARCH/REPLACE blocks at a time, then wait for the user to respond with the result of the operation before following up with another replace_in_file call to make additional edits.
(If you run into this error 3 times in a row, you may use the write_to_file tool as a fallback.)
</error>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
src/composables/useObjectSelection.js

# VSCode Open Tabs
src/composables/useObjectSelection.js

# Current Time
2025/8/5 下午5:05:06 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
546 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
README.md 的项目结构部分已包含 useObjectSelection.js，但未体现“已修改”或“高亮逻辑优化”说明。可在 composables/ 目录下 useObjectSelection.js 行尾加注释，标明“高亮逻辑优化”。
</thinking>

<replace_in_file>
<path>README.md</path>
<diff>
------- SEARCH
│   ├── composables/           # Vue Composition API 可组合函数
│   │   ├── useScene.js        # 场景管理
│   │   ├── useObjectSelection.js  # 对象选择
│   │   ├── useTransform.js    # 变换操作
│   │   └── useAssets.js       # 资源管理
=======
│   ├── composables/           # Vue Composition API 可组合函数
│   │   ├── useScene.js        # 场景管理
│   │   ├── useObjectSelection.js  # 对象选择（高亮逻辑优化）
│   │   ├── useTransform.js    # 变换操作
│   │   └── useAssets.js       # 资源管理
+++++++ REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'README.md'] Result:
The content was successfully saved to README.md.

Here is the full, updated content of the file that was saved:

<final_file_content path="README.md">
# 3D 场景编辑器 (Three Editor by AI)

一个基于 Vue 3 + Three.js 的现代化3D场景编辑器，支持三维模型的拖放、调整和属性配置。

## ✅ 功能体系
- 3D场景渲染和管理
- 多种基础几何体创建
- 完整的对象变换系统（移动、旋转、缩放）
- 单选（多选、框选功能已移除，仅支持单选）
- 撤销重做历史记录
- 3D模型和纹理加载（GLTF、OBJ、FBX等格式）
- 拖拽上传和资源管理
- 相机控制和预设视角
- 材质编辑和属性调整
- 场景序列化和导入导出

## 🚀 技术栈

- **前端框架**: Vue 3 + Vite
- **3D引擎**: Three.js
- **构建工具**: Vite
- **网络请求**: Fetch API
- **工具库**: 
  - Lodash - 实用工具函数库
  - Day.js - 轻量级日期时间库

## 📁 项目结构

```
three-editor-by-ai/
├── public/                     # 静态资源
│   └── vite.svg
├── src/
│   ├── assets/                 # 静态资源 (3D模型、纹理等)
│   │   └── vue.svg
│   ├── components/             # Vue 组件
│   │   ├── editor/            # 编辑器 UI 组件
│   │   │   ├── PropertyPanel.vue    # 属性面板
│   │   │   ├── Toolbar.vue          # 工具栏
│   │   │   ├── AssetBrowser.vue     # 资源浏览器
│   │   │   └── Inspector.vue        # 对象检查器
│   │   ├── scene/             # 3D 场景组件
│   │   │   ├── SceneViewer.vue      # 主场景视图
│   │   │   ├── PerformanceMonitor.vue   # 性能监控组件
│   │   │   ├── InteractionHints.vue     # 操作提示组件
│   │   │   ├── ViewportControls.vue     # 视图控制面板组件
│   │   │   ├── CubeViewportControls.vue # 立方体视角控件，6面点击切换视角，镜头联动
│   │   │   ├── ObjectGizmo.vue      # 对象操作控制器
│   │   │   └── Camera.vue           # 相机控制
│   ├── composables/           # Vue Composition API 可组合函数
│   │   ├── useScene.js        # 场景管理
│   │   ├── useObjectSelection.js  # 对象选择（高亮逻辑优化）
│   │   ├── useTransform.js    # 变换操作
│   │   └── useAssets.js       # 资源管理
│   ├── core/                  # 核心 Three.js 逻辑
│   │   ├── SceneManager.js    # 场景管理器
│   │   ├── ObjectManager.js   # 对象管理器
│   │   ├── InputManager.js    # 输入处理
│   │   └── AssetLoader.js     # 资源加载器
│   ├── api/                  # API 接口
│   │   ├── *.api.js            # 各种模块API接口
│   ├── utils/                 # 工具函数
│   │   ├── mathUtils.js      # 数学工具
│   │   ├── geometryUtils.js  # 几何工具
│   │   └── fileUtils.js      # 文件处理工具
│   ├── App.vue               # 根组件
│   ├── main.js               # 应用入口
│   └── style.css             # 全局样式
├── .gitignore                # Git 忽略文件
├── index.html                # HTML 模板
├── package.json              # 项目配置
├── package-lock.json         # 依赖锁定
├── vite.config.js            # Vite 配置
└── README.md                 # 项目说明
```

## 🎯 主要功能

- **3D场景渲染**: 基于 Three.js 的高性能 3D 渲染
- **几何体创建**: 支持多种基础和扩展几何体创建
  - 基础几何体: 立方体、球体、圆柱体、平面、圆锥体、圆环体
  - 扩展几何体: 十二面体、二十面体、八面体、四面体、环形、管道
  - 灯光对象: 方向光、点光源、聚光灯、环境光、半球光
  - 其他对象: 相机、空对象、文本、精灵
- **模型管理**: 支持多种 3D 模型格式的导入和管理
- **交互操作**: 
  - 资源浏览器中直接添加几何体
  - 实时变换操作 (位移、旋转、缩放)
  - 单对象选择和编辑（多选、框选功能已移除，仅支持单选）
- **属性编辑**: 实时修改模型的材质、几何体等属性
- **场景管理**: 完整的场景层级管理和序列化
- **资源浏览**: 内置资源管理器，支持模型预览和几何体创建

## 🏗️ 架构设计

### 组件层次

1. **UI 层** (`components/editor/`): 负责用户界面和交互
2. **3D 渲染层** (`components/scene/`): 处理 3D 场景渲染和显示
3. **逻辑层** (`composables/`, `core/`): 业务逻辑和状态管理
4. **API层** (`api/`): 数据请求和外部接口
5. **工具层** (`utils/`): 通用工具函数

### 技术特点

- **响应式状态**: 使用 Vue 3 Composition API 管理应用状态
- **模块化设计**: 清晰的代码组织和职责分离
- **类型安全**: 良好的代码结构支持 TypeScript 迁移
- **性能优化**: 合理的组件懒加载和渲染优化

## 📋 开发规范

- 遵循 Vue 3 组合式 API 最佳实践
- 使用 ES6+ 语法特性
- 组件命名采用 PascalCase
- 文件和目录命名采用 camelCase
- Git 提交信息格式: `feat: 功能描述`

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/5 下午5:05:19 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
318 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
所有高亮逻辑优化已完成，README.md 项目结构已同步更新。根据 .clinerules/要求，任务完成后应提交 git，并写中文 feat: 注释。
</thinking>

<execute_command>
<command>git add src/composables/useObjectSelection.js README.md; git commit -m "feat: 优化对象选中与悬停高亮材质逻辑，防止选中高亮被悬停覆盖"</command>
<requires_approval>true</requires_approval>
</execute_command>

---

**User:**

[execute_command for 'git add src/composables/useObjectSelection.js README.md; git commit -m "feat: 优化对象选中与悬停高亮材质逻辑，防止选中高亮被悬停覆盖"'] Result:
Command executed.
Output:
[main 0035a65] feat: 优化对象选中与悬停高亮材质逻辑，防止选中高亮被悬停覆盖
 1 file changed, 34 insertions(+), 20 deletions(-)
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/5 下午5:05:47 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
173 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<attempt_completion>
<result>
已完成 useObjectSelection.js 的高亮材质逻辑优化，实现如下：
- 选中对象时 userData 记录 selectionMaterial，悬停时记录 hoverMaterial。
- removeHoverHighlight 判断是否选中，优先恢复 selectionMaterial，否则恢复 originalMaterial。
- 取消选中时，恢复 originalMaterial，并移除 selectionMaterial。
- README.md 项目结构已同步标注“高亮逻辑优化”。
- 变更已提交，提交信息："feat: 优化对象选中与悬停高亮材质逻辑，防止选中高亮被悬停覆盖"。
</result>
</attempt_completion>

---

**User:**

[attempt_completion] Result:
The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.
<feedback>
git push
</feedback>
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/5 下午5:06:00 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
210 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<execute_command>
<command>git push</command>
<requires_approval>true</requires_approval>
</execute_command>

---

**User:**

[execute_command for 'git push'] Result:
Command executed.
Output:
git: 'credential-manager-core' is not a git command. See 'git --help'.
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 12 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 807 bytes | 807.00 KiB/s, done.
Total 5 (delta 4), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas:   0% (0/4)remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
To https://github.com/fellow99/three-editor-by-ai.git
   0749bb9..0035a65  main -> main
<environment_details>
# VSCode Visible Files
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/0
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/1
C:/response_9d24c334-8dec-41c2-a3e0-32eb019f545c/2
README.md

# VSCode Open Tabs
src/composables/useObjectSelection.js
README.md

# Current Time
2025/8/5 下午5:06:17 (Asia/Shanghai, UTC+8:00)

# Context Window Usage
98 / 111.452K tokens used (0%)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<attempt_completion>
<result>
所有高亮材质逻辑优化已完成并推送至远程仓库。src/composables/useObjectSelection.js 现已支持选中与悬停高亮互不干扰，README.md 项目结构已同步更新，相关变更已提交并成功 git push。
</result>
</attempt_completion>

